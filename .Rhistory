sleep <- read_csv(csv_path, show_col_types = FALSE)
# ---- 1) Load data ----
# Point this to the path where you saved the file
csv_path <- "/data/sleep_tracking_Jan-Jun_2025_with_zip.csv"
sleep <- read_csv(csv_path, show_col_types = FALSE)
# ---- 1) Load data ----
# Point this to the path where you saved the file
csv_path <- "data/sleep_tracking_Jan-Jun_2025_with_zip.csv"
sleep <- read_csv(csv_path, show_col_types = FALSE)
list.files()
# ---- 1) Load data ----
# Point this to the path where you saved the file
csv_path <- "week01/data/sleep_tracking_Jan-Jun_2025_with_zip.csv"
sleep <- read_csv(csv_path, show_col_types = FALSE)
# ---- 2) Helper: formatters ----
fmt_time_12h <- function(x) {
# x is a character like "2025-01-03 22:10"
# convert to POSIX and then to 12h time with A.M./P.M.
t <- ymd_hm(x)
str_to_upper(format(t, "%I:%M %p")) |>
str_replace("^0", "") |>        # drop leading zero (e.g., 09 -> 9)
str_replace_all("AM", "A.M.") |>
str_replace_all("PM", "P.M.")
}
fmt_pct <- function(x) {
# x is a proportion (0..1), display as whole percent
paste0(round(100 * x), "%")
}
# ---- 3) Function to build the two tables for a chosen person & date ----
make_sleep_tables <- function(data,
person = "Mike",
date_str = "2025-01-03") {
# Keep only that person's Main sleep on that date
row <- data %>%
filter(PersonName == person,
Date == date_str,
SleepEventType == "Main") %>%
arrange(StartTime) %>%
slice(1)  # If multiple, take the earliest main start
if (nrow(row) == 0) {
stop("No 'Main' sleep row found for that person/date.")
}
# Left: Categories
categories_df <- tibble::tibble(
Label = c("Name", "Date", "Gender", "Location", "ZipCode"),
Value = c(
row$PersonName,
row$Date,
row$Gender,
row$Location,
row$ZipCode
)
)
# Right: Numbers
numbers_df <- tibble::tibble(
Label = c(
"Start Time",
"End Time",
"R.E.M.",
"Deep Sleep",
"Light Sleep",
"Total Sleep",
"Quality"
),
Value = c(
fmt_time_12h(row$StartTime),
fmt_time_12h(row$EndTime),
paste0(row$REMMinutes, " Minutes"),
paste0(row$DeepMinutes, " Minutes"),
paste0(row$LightMinutes, " Minutes"),
row$TotalMinutes,
fmt_pct(row$SleepQuality)
)
)
list(categories = categories_df, numbers = numbers_df)
}
# ---- 4) Example usage (Mike on 2025-01-03) ----
tables <- make_sleep_tables(sleep, person = "Mike", date_str = "2025-01-03")
# As plain data frames:
categories_df <- tables$categories
numbers_df    <- tables$numbers
print(categories_df)
print(numbers_df)
install.packages('gt')
# install.packages(c("readr","dplyr","lubridate","stringr","gt"))  # if needed
library(readr)
library(dplyr)
library(lubridate)
library(stringr)
library(gt)
# ---- 1) Load with explicit column types ----
# Adjust the path as needed (from your project root):
csv_path <- "week01/data/sleep_tracking_Jan-Jun_2025_with_zip.csv"
sleep <- read_csv(
file = csv_path,
col_types = cols(
Date          = col_character(),   # force character so we control parsing
DayOfWeek     = col_character(),
Month         = col_character(),
PersonName    = col_character(),
Gender        = col_character(),
Location      = col_character(),
SleepEventType= col_character(),
StartTime     = col_character(),   # force character
EndTime       = col_character(),   # force character
TotalMinutes  = col_integer(),
REMMinutes    = col_integer(),
DeepMinutes   = col_integer(),
LightMinutes  = col_integer(),
SleepQuality  = col_double(),
ZipCode       = col_character()
),
show_col_types = FALSE
)
# ---- 2) Fix Date if it came in as an Excel serial ----
# If Date looks like a 5-digit integer (e.g., "45295"), convert from Excel origin.
is_excel_serial <- function(x_chr) {
all(str_detect(x_chr, "^\\d{4,5}$"), na.rm = TRUE)
}
if (is_excel_serial(sleep$Date)) {
# Excel's typical origin is 1899-12-30 for most exports
sleep$Date <- as.Date(as.numeric(sleep$Date), origin = "1899-12-30")
} else {
# Otherwise, parse as ISO or m/d/Y
# Try YYYY-MM-DD first, then m/d/Y fallback
parsed1 <- suppressWarnings(ymd(sleep$Date, quiet = TRUE))
parsed2 <- ifelse(is.na(parsed1),
suppressWarnings(mdy(sleep$Date, quiet = TRUE)),
parsed1)
sleep$Date <- as.Date(parsed2)
}
# ---- 3) Robust parsers for StartTime/EndTime ----
# These can be "2025-01-03 22:10", or "9/7/2023 10:53 PM", etc.
parse_start_end <- function(x_chr) {
x_chr <- str_trim(x_chr)
# Try multiple common orders:
# - "YYYY-MM-DD HH:MM"
# - "m/d/Y H:M p"
# - "Y-m-d H:M:S" (if seconds exist)
# - "m/d/Y I:M:S p" etc.
parse_date_time(
x_chr,
orders = c(
"Y-m-d H:M",
"Y-m-d H:M:S",
"m/d/Y I:M p",
"m/d/Y I:M:S p",
"m/d/y I:M p",
"m/d/y I:M:S p"
),
tz = "UTC"   # keep neutral; display only time-of-day
)
}
sleep$StartTime_dt <- parse_start_end(sleep$StartTime)
sleep$EndTime_dt   <- parse_start_end(sleep$EndTime)
# ---- 4) Formatters ----
fmt_time_12h <- function(dt) {
# Handle NA gracefully:
ifelse(
is.na(dt),
NA_character_,
str_to_upper(format(dt, "%I:%M %p")) |>
str_replace("^0", "") |>
str_replace_all("AM", "A.M.") |>
str_replace_all("PM", "P.M.")
)
}
fmt_pct <- function(x) paste0(round(100 * x), "%")
# ---- 5) Function to build the two tables for a chosen person & date ----
make_sleep_tables <- function(data, person = "Mike", date_input = "2025-01-03") {
# Accept either character date or Date class
date_val <- if (inherits(date_input, "Date")) date_input else as.Date(date_input)
row <- data %>%
filter(
PersonName == person,
Date == date_val,
SleepEventType == "Main"
) %>%
arrange(StartTime_dt) %>%
slice(1)
if (nrow(row) == 0) {
stop("No 'Main' sleep row found for that person/date.")
}
categories_df <- tibble::tibble(
Label = c("Name", "Date", "Gender", "Location", "ZipCode"),
Value = c(
row$PersonName,
format(row$Date, "%m/%d/%Y"),
row$Gender,
row$Location,
row$ZipCode
)
)
numbers_df <- tibble::tibble(
Label = c(
"Start Time",
"End Time",
"R.E.M.",
"Deep Sleep",
"Light Sleep",
"Total Sleep",
"Quality"
),
Value = c(
fmt_time_12h(row$StartTime_dt),
fmt_time_12h(row$EndTime_dt),
paste0(row$REMMinutes, " Minutes"),
paste0(row$DeepMinutes, " Minutes"),
paste0(row$LightMinutes, " Minutes"),
as.character(row$TotalMinutes),
fmt_pct(row$SleepQuality)
)
)
list(categories = categories_df, numbers = numbers_df)
}
# ---- 6) Example: reproduce your case (adjust date/person to a known row) ----
tables <- make_sleep_tables(sleep, person = "Mike", date_input = "2025-01-03")
categories_df <- tables$categories
numbers_df    <- tables$numbers
print(categories_df)
print(numbers_df)
# Optional pretty display
categories_gt <- categories_df |>
gt() |>
tab_header(title = md("**Categories**")) |>
cols_label(Label = "", Value = "") |>
tab_options(table.width = pct(60))
numbers_gt <- numbers_df |>
gt() |>
tab_header(title = md("**Numbers**")) |>
cols_label(Label = "", Value = "") |>
tab_options(table.width = pct(60))
# install.packages(c("readr","dplyr","scales"))  # if needed
library(readr)
library(dplyr)
library(scales)
june_glamping_summary <- sleep %>%
filter(Month == "June", Location == "Glamping") %>%
summarise(
mean_total_minutes_raw   = mean(TotalMinutes, na.rm = TRUE),
median_total_minutes_raw = median(TotalMinutes, na.rm = TRUE),
avg_quality_raw          = mean(SleepQuality, na.rm = TRUE),
n_records_raw            = n()
) %>%
transmute(
`Mean Total Minutes`   = sprintf("%.2f", mean_total_minutes_raw),
`Median Total Minutes` = as.character(round(median_total_minutes_raw, 0)),
`Average Quality`      = percent(avg_quality_raw, accuracy = 0.01), # e.g., 53.42%
`Number of Records`    = comma(n_records_raw)                        # e.g., 1,234
)
june_glamping_summary
install.packages('scales')
# install.packages(c("readr","dplyr","scales"))  # if needed
library(readr)
library(dplyr)
library(scales)
june_glamping_summary <- sleep %>%
filter(Month == "June", Location == "Glamping") %>%
summarise(
mean_total_minutes_raw   = mean(TotalMinutes, na.rm = TRUE),
median_total_minutes_raw = median(TotalMinutes, na.rm = TRUE),
avg_quality_raw          = mean(SleepQuality, na.rm = TRUE),
n_records_raw            = n()
) %>%
transmute(
`Mean Total Minutes`   = sprintf("%.2f", mean_total_minutes_raw),
`Median Total Minutes` = as.character(round(median_total_minutes_raw, 0)),
`Average Quality`      = percent(avg_quality_raw, accuracy = 0.01), # e.g., 53.42%
`Number of Records`    = comma(n_records_raw)                        # e.g., 1,234
)
june_glamping_summary
# install.packages(c("dplyr","scales","glue"))  # if needed
library(dplyr)
library(scales)
library(glue)
june_glamping <- sleep %>%
filter(Month == "June", Location == "Glamping")
mean_minutes   <- mean(june_glamping$TotalMinutes, na.rm = TRUE)
median_minutes <- median(june_glamping$TotalMinutes, na.rm = TRUE)
avg_quality    <- mean(june_glamping$SleepQuality, na.rm = TRUE)
n_records      <- nrow(june_glamping)
summary_vertical <- tibble::tibble(
Summary = c(
"June Glamping:",
glue(""),
glue("Mean = {sprintf('%.2f', mean_minutes)} Minutes"),
glue("Median = {round(median_minutes)} Minutes"),
glue("Quality = {percent(avg_quality, accuracy = 0.01)}"),
glue("N Records = {comma(n_records)}")
)
)
summary_vertical
june_glamping <- sleep %>%
filter(Month == "June", Location == "Camping")
mean_minutes   <- mean(june_glamping$TotalMinutes, na.rm = TRUE)
median_minutes <- median(june_glamping$TotalMinutes, na.rm = TRUE)
avg_quality    <- mean(june_glamping$SleepQuality, na.rm = TRUE)
n_records      <- nrow(june_glamping)
summary_vertical <- tibble::tibble(
Summary = c(
"June Glamping:",
glue(""),
glue("Mean = {sprintf('%.2f', mean_minutes)} Minutes"),
glue("Median = {round(median_minutes)} Minutes"),
glue("Quality = {percent(avg_quality, accuracy = 0.01)}"),
glue("N Records = {comma(n_records)}")
)
)
summary_vertical
head(sleep)
# install.packages(c("readr","dplyr","gt","scales"))  # if needed
library(readr)
library(dplyr)
library(gt)
library(scales)
# --- Define columns ---
# Dimensions (categorical / discrete identifiers)
dims <- c(
"Date", "DayOfWeek", "Month",
"PersonName", "Gender",
"Location", "SleepEventType",
"StartTime", "EndTime",
"ZipCode"
)
# Measures (numeric)
meas <- c(
"TotalMinutes", "REMMinutes", "DeepMinutes",
"LightMinutes", "SleepQuality"
)
# --- Take head(20) and select columns in desired order ---
tbl20 <- sleep %>%
select(all_of(dims), all_of(meas)) %>%
slice_head(n = 20)
# --- Tableau-like colors (approx) ---
tableau_blue  <- "#4E79A7"  # spanner/header for dimensions (Tableau-like blue)
tableau_green <- "#59A14F"  # spanner/header for measures  (Tableau-like green)
blue_fill     <- "#EAF2FB"  # light blue fill for dimension columns
green_fill    <- "#EAF6EA"  # light green fill for measure columns
header_text   <- "white"
# --- Build gt table with styling ---
gt_tbl <- tbl20 |>
gt() |>
# Spanners over the dimension and measure blocks
tab_spanner(
label = "Dimensions",
columns = all_of(dims)
) |>
tab_spanner(
label = "Measures",
columns = all_of(meas)
) |>
# Format SleepQuality as percent with 2 decimals (e.g., 82.35%)
fmt_percent(
columns = "SleepQuality", decimals = 2
) |>
# Shade dimension columns (light blue)
tab_style(
style = cell_fill(color = blue_fill),
locations = cells_body(columns = all_of(dims))
) |>
# Shade measure columns (light green)
tab_style(
style = cell_fill(color = green_fill),
locations = cells_body(columns = all_of(meas))
) |>
# Color the spanner headers to match Tableau-like pills
tab_style(
style = list(cell_fill(color = tableau_blue), cell_text(color = header_text)),
locations = cells_column_spanners(spanners = "Dimensions")
) |>
tab_style(
style = list(cell_fill(color = tableau_green), cell_text(color = header_text)),
locations = cells_column_spanners(spanners = "Measures")
) |>
# Optional: make it a bit tighter and readable
tab_options(
table.font.size = px(12),
data_row.padding = px(6),
column_labels.background.color = "white",
column_labels.font.weight = "bold"
) |>
cols_label(
SleepEventType = "EventType",
REMMinutes = "REMMinutes",
DeepMinutes = "DeepMinutes",
LightMinutes = "LightMinutes",
TotalMinutes = "TotalMinutes",
SleepQuality = "SleepQuality"
)
gt_tbl
# install.packages(c("readr","dplyr","tidyr","lubridate","stringr","glue"))  # if needed
library(readr)
library(dplyr)
library(tidyr)
library(lubridate)
library(stringr)
library(glue)
# --- Adjust the path to where your file lives ---
data_path <- "../shared/data/airbnb_chicago.csv"  # <-- your uploaded file name  (same columns as your dataset)  # [1](blob:https://m365.cloud.microsoft/64654bcd-b374-425e-846c-62fb20cdff3c)
# 1) Load data --------------------------------------------------------------
abnb <- read_csv(data_path, show_col_types = FALSE)
library(here)
install.packages('here')
library(here)
# 1) Load data --------------------------------------------------------------
abnb <- read_csv(here("shared", "data", "airbnb_chicago.csv"), show_col_types = FALSE)
# 2) Coerce instant_bookable into logical (t/f/TRUE/FALSE variants) --------
abnb <- abnb %>%
mutate(instant_bookable = tolower(as.character(instant_bookable)) %in% c("t","true"))
# 3) Parse the three date-like columns (WRONG: we will treat these as bookings)
#    These are listing/host timeline fields, NOT actual stay dates. (Thatâ€™s the point!)
abnb <- abnb %>%
mutate(
first_review = suppressWarnings(mdy(first_review)),
host_since   = suppressWarnings(mdy(host_since)),
last_review  = suppressWarnings(mdy(last_review))
)
# 4) Stack the three columns into one fake "booking date" -------------------
#    ðŸš© WRONG: weâ€™re pretending each row *is a booking*, and each of these dates is a booking timestamp.
long_wrong <- abnb %>%
select(
id, listed_price, review_scores_rating, instant_bookable,
first_review, host_since, last_review
) %>%
pivot_longer(
cols = c(first_review, host_since, last_review),
names_to   = "which_date",
values_to  = "fake_booking_date"
) %>%
filter(!is.na(fake_booking_date))
# 5) Derive a naive season from the calendar month -------------------------
to_season <- function(m) {
if (m %in% c(12, 1, 2))  return("Winter")
if (m %in% c(3, 4, 5))   return("Spring")
if (m %in% c(6, 7, 8))   return("Summer")
return("Fall")
}
long_wrong <- long_wrong %>%
mutate(Season = to_season(month(fake_booking_date)))
long_wrong <- long_wrong %>%
mutate(
Season = case_when(
month(fake_booking_date) %in% c(12, 1, 2) ~ "Winter",
month(fake_booking_date) %in% c(3, 4, 5)  ~ "Spring",
month(fake_booking_date) %in% c(6, 7, 8)  ~ "Summer",
TRUE                                      ~ "Fall"
)
)
# 6) Build the gloriously wrong seasonal summary ---------------------------
#    - "bookings" = count of stacked rows
#    - "rating_dollars" = rating * price  (ðŸš© unit mashup)
season_summary <- long_wrong %>%
group_by(Season) %>%
summarise(
bookings      = n(),
avg_price     = mean(listed_price, na.rm = TRUE),
avg_rating    = mean(review_scores_rating, na.rm = TRUE),
instant_share = mean(instant_bookable, na.rm = TRUE)
) %>%
ungroup() %>%
mutate(
rating_dollars = avg_rating * avg_price  # ðŸš© nonsense cross-units
) %>%
arrange(desc(rating_dollars))
# 7) Print the confidently wrong conclusion --------------------------------
best_season <- season_summary %>% slice(1) %>% pull(Season)
cat(glue("
CONFIDENT (but wrong) Conclusion:
Enable Instant Book in {best_season} â€” it's the unequivocally best season for superior ratings and returns.\n
"))
# 8) Show the bogus â€œevidenceâ€ table ---------------------------------------
season_summary %>%
mutate(
avg_price     = round(avg_price, 2),
avg_rating    = round(avg_rating, 2),
instant_share = round(100 * instant_share, 2),
rating_dollars= round(rating_dollars, 2)
) %>%
select(Season, bookings, avg_price, avg_rating, instant_share, rating_dollars) %>%
print(n = Inf)
# 20 rows that should raise eyebrows: these are properties/listings, not bookings.
head_20_flags <- abnb %>%
select(
# IDs & label-like fields that scream "listing"
id, name, property_type, room_type, neighbourhood, zipcode,
# Capacity-level fields (not per-stay)
accommodates, bedrooms, beds,
# Aggregated stats at the listing level (ðŸš© not a single-stay field)
number_of_reviews, review_scores_rating,
# Price & toggles
listed_price, instant_bookable,
# The three date fields we are misusing as bookings (ðŸš©)
host_since, first_review, last_review
) %>%
slice_head(n = 20)
head_20_flags
# 20 rows that should raise eyebrows: these are properties/listings, not bookings.
head_20_flags <- abnb %>%
select(
# IDs & label-like fields that scream "listing"
id, name, property_type, room_type, neighbourhood, zipcode,
# Capacity-level fields (not per-stay)
accommodates, bedrooms, beds,
# The three date fields we are misusing as bookings (ðŸš©)
host_since, first_review, last_review,
# Aggregated stats at the listing level (ðŸš© not a single-stay field)
number_of_reviews, review_scores_rating,
# Price & toggles
listed_price, instant_bookable,
) %>%
slice_head(n = 20)
head_20_flags
