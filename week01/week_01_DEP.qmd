---
title: "ECO 230 Section 012"
author: "Mike Boland, MBA"
format:
  revealjs:
    theme:
      - default
      - ../shared/styles/boland-reveal.scss
    css: ../shared/styles/accessibility.css
    slide-number: true
    hash: true
    controls: true
    transition: fade
    pdf-export: true
    toc: false
    self-contained: false
    center: false
    margin: 0
execute:
  echo: false
---

```{r}
#imports
source('../shared/scripts/gt_boland.R')
library(readr)
library(dplyr)
library(tidyr)
library(lubridate)
library(stringr)
library(glue)
library(here)
library(eco230r)

```


# Can you trust this conclusion?

## Use Instant Booking Wisely

Airbnb Owners should enable **Instant Booking** in Fall ‚Äî it's the unequivocally best season for superior ratings and returns.

```{r airbnb echo:false}

#install.packages(c("readr","dplyr","tidyr","lubridate","stringr","glue","here"))  # if needed
library(readr)
library(dplyr)
library(tidyr)
library(lubridate)
library(stringr)
library(glue)
library(here)
library(eco230r)


# --- Adjust the path to where your file lives ---
data_path <- here("shared", "data", "airbnb_chicago.csv")
data_path_sim <- here("week01","data","airbnb_chicago_two_properties_bookings_sim.csv"
)

# 1) Load data --------------------------------------------------------------
abnb <- read_csv(data_path, show_col_types = FALSE)
abnb_sim <- read_csv(data_path_sim, show_col_types = FALSE)


# 2) Coerce instant_bookable into logical (t/f/TRUE/FALSE variants) --------
abnb <- abnb %>%
  mutate(instant_bookable = tolower(as.character(instant_bookable)) %in% c("t","true"))

# 3) Parse the three date-like columns (WRONG: we will treat these as bookings)
#    These are listing/host timeline fields, NOT actual stay dates. (That‚Äôs the point!)
abnb <- abnb %>%
  mutate(
    first_review = suppressWarnings(mdy(first_review)),
    host_since   = suppressWarnings(mdy(host_since)),
    last_review  = suppressWarnings(mdy(last_review))
  )

# 4) Stack the three columns into one fake "booking date" -------------------
#    üö© WRONG: we‚Äôre pretending each row *is a booking*, and each of these dates is a booking timestamp.
long_wrong <- abnb %>%
  select(
    id, listed_price, review_scores_rating, instant_bookable,
    first_review, host_since, last_review
  ) %>%
  pivot_longer(
    cols = c(first_review, host_since, last_review),
    names_to   = "which_date",
    values_to  = "fake_booking_date"
  ) %>%
  filter(!is.na(fake_booking_date))

# 5) Derive a naive season from the calendar month -------------------------
to_season <- function(m) {
  if (m %in% c(12, 1, 2))  return("Winter")
  if (m %in% c(3, 4, 5))   return("Spring")
  if (m %in% c(6, 7, 8))   return("Summer")
  return("Fall")
}


long_wrong <- long_wrong %>%
  mutate(
    Season = case_when(
      month(fake_booking_date) %in% c(12, 1, 2) ~ "Winter",
      month(fake_booking_date) %in% c(3, 4, 5)  ~ "Spring",
      month(fake_booking_date) %in% c(6, 7, 8)  ~ "Summer",
      TRUE                                      ~ "Fall"
    )
  )


# 6) Build the gloriously wrong seasonal summary ---------------------------
#    - "bookings" = count of stacked rows
#    - "rating_dollars" = rating * price  (üö© unit mashup)
season_summary <- long_wrong %>%
  group_by(Season) %>%
  summarise(
    bookings      = n(),
    avg_price     = mean(listed_price, na.rm = TRUE),
    avg_rating    = mean(review_scores_rating, na.rm = TRUE),
    instant_share = mean(instant_bookable, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  mutate(
    rating_dollars = avg_rating * avg_price  # üö© nonsense cross-units
  ) %>%
  arrange(desc(rating_dollars))

# 7) Print the confidently wrong conclusion --------------------------------
best_season <- season_summary %>% slice(1) %>% pull(Season)

#cat(glue("
#CONFIDENT (but wrong) Conclusion:
#Enable Instant Book in {best_season} ‚Äî it's the unequivocally best season for superior ratings and returns.\n
#"))




```

```{r ab_flawed}

library(dplyr)
library(gt)
library(scales)



season_summary %>%
  mutate(
    `Avg Price (USD)` = dollar(avg_price, accuracy = 0.01),
    `Avg Rating`      = number(avg_rating, accuracy = 0.01),
    `Instant-Book %`  = percent(instant_share, accuracy = 0.01),
    `Rating √ó Price`  = number(rating_dollars, big.mark = ",", accuracy = 0.01)
  ) %>%
  select(
    Season,
    `Bookings` = bookings,
    `Avg Price (USD)`, `Avg Rating`, `Instant-Book %`, `Rating √ó Price`
  ) %>%
  gt() %>%
  # Minimal typography‚Äîno header, notes, or shading
  fmt_number(columns = "Bookings", decimals = 0, sep_mark = ",") %>%
  tab_options(
    table.width = pct(100),
    table.font.size = px(24),
    data_row.padding = px(4),
    column_labels.font.weight = "bold",
    table.border.top.width = px(0),
    table.border.bottom.width = px(0),
    column_labels.border.top.width = px(0),
    column_labels.border.bottom.width = px(0)
  )



```

## [Sample Airbnb Data]{.sr-only}

```{r ab_detail}


# Minimalist, slide-friendly gt table for head_20_flags
library(dplyr)
library(gt)
library(stringr)
library(scales)
library(lubridate)


# 20 rows that should raise eyebrows: these are properties/listings, not bookings.
head_20_flags <- abnb %>%
  select(
    # IDs & label-like fields that scream "listing"
    id, name, property_type, room_type, neighbourhood, zipcode,
    # Capacity-level fields (not per-stay)
    accommodates, bedrooms, beds,
    # The three date fields we are misusing as bookings (üö©)
    host_since, first_review, last_review,
    # Aggregated stats at the listing level (üö© not a single-stay field)
    number_of_reviews, review_scores_rating,
    # Price & toggles
    listed_price, instant_bookable,
    
  ) %>%
  slice_head(n = 20)


# OPTIONAL: if you want to (slightly) shorten long listing names before gt
head_20_print <- head_20_flags %>%
  mutate(
    # Present booleans compactly
    instant_bookable = ifelse(instant_bookable, "Yes", "No"),
    # Nicely formatted numbers
    listed_price = dollar(listed_price, accuracy = 0.01),
    number_of_reviews = number(number_of_reviews, big.mark = ",", accuracy = 1),
    review_scores_rating = number(review_scores_rating, accuracy = 0.01),
    # Format dates (use what fits your class better)
    host_since   = format(as.Date(host_since),   "%Y-%m-%d"),
    first_review = format(as.Date(first_review), "%Y-%m-%d"),
    last_review  = format(as.Date(last_review),  "%Y-%m-%d"),
    # Light truncation to avoid column blowout on slides
    name           = str_trunc(name,           38),
    property_type  = str_trunc(property_type,  18),
    room_type      = str_trunc(room_type,      18),
    neighbourhood  = str_trunc(neighbourhood,  18),
    zipcode        = str_trunc(as.character(zipcode), 10)
  )

# Render with strict widths + tight spacing to fit 20 rows on a slide
gt_tbl <- head_20_print %>%
  select(
    id, name, property_type, room_type, neighbourhood, zipcode,
    accommodates, bedrooms, beds,
    host_since, first_review, last_review,
    number_of_reviews, review_scores_rating,
    listed_price, instant_bookable
  ) %>%
  gt() %>%
  # Column labels: short & readable (keeps header height small)
  cols_label(
    id = "ID",
    name = "Name",
    property_type = "Property",
    room_type = "Room",
    neighbourhood = "Neighborhood",
    zipcode = "ZIP",
    accommodates = "Sleeps",
    bedrooms = "BR",
    beds = "Beds",
    host_since = "Host Since",
    first_review = "First Review",
    last_review = "Last Review",
    number_of_reviews = "# Reviews",
    review_scores_rating = "Rating",
    listed_price = "Price",
    instant_bookable = "IB?"
  ) %>%
  # Force compact widths: adjust as needed for your slide theme
  cols_width(
    id ~ px(68),
    name ~ px(220),
    property_type ~ px(120),
    room_type ~ px(110),
    neighbourhood ~ px(120),
    zipcode ~ px(78),
    accommodates ~ px(70),
    bedrooms ~ px(60),
    beds ~ px(60),
    host_since ~ px(100),
    first_review ~ px(100),
    last_review ~ px(100),
    number_of_reviews ~ px(90),
    review_scores_rating ~ px(80),
    listed_price ~ px(90),
    instant_bookable ~ px(50)
  ) %>%
  # Minimal borders, tight padding, small font to fit 20 rows
  tab_options(
    table.width = pct(100),
    table.font.size = px(10),    # try px(11) if still tight
    data_row.padding = px(2),    # tighter rows
    column_labels.padding = px(2),
    table.border.top.width = px(0),
    table.border.bottom.width = px(0),
    column_labels.border.top.width = px(0),
    column_labels.border.bottom.width = px(0)
  ) %>%
  # Prevent long strings from expanding columns further
  opt_vertical_padding(scale = 0.75) %>%
  opt_horizontal_padding(scale = 0.9)

gt_tbl

```

# What is Statistics?

## {background-image="media/images/w01_s03_image.png" background-position="left center" background-size="auto 150%" background-repeat="no-repeat" fig-alt="Photo of several dogs lying on a blanket; playful opener for the topic."}


:::: {.columns}

::: {.column width="50%"}



:::

::: {.column width="50%"}

What is **Statistics**?

What is **Analytics**?

:::

::::

## {background-image="media/images/w01_s03_image.png" background-position="left center" background-size="auto 150%" background-repeat="no-repeat" fig-alt="There are three dogs in this picture. One has black fur, one has brown, one is an idiot."}


:::: {.columns}

::: {.column width="50%"}



:::

::: {.column width="50%"}

**Analytics** is the **art** of finding out what is in your data.

:::

::::


## {background-image="media/images/w01_s03_image.png" background-position="left center" background-size="auto 150%" background-repeat="no-repeat" fig-alt="We don't need to see every dog in the world to know that most dogs have fur, they generally have 4 paws etc..."}


:::: {.columns}

::: {.column width="50%"}



:::

::: {.column width="50%"}

If you can (with some effort) find the answer with certainty you are using **Analytics**.

:::

::::

## {background-image="media/images/w01_s03_image.png" background-position="left center" background-size="auto 150%" background-repeat="no-repeat" fig-alt="When we need to get specific we need to go beyond analytics. E.g. how much food does the average dog eat?"}


:::: {.columns}

::: {.column width="50%"}



:::

::: {.column width="50%"}

**Analytics** deals with what you know.

**Statistics** deals with what you do not know.

:::

::::

## {background-image="media/images/w01_s03_image.png" background-position="left center" background-size="auto 150%" background-repeat="no-repeat" fig-alt="Analytics helps us frame what questions we need clarity on and which questions we need the discipline of statistics to answer."}


:::: {.columns}

::: {.column width="50%"}



:::

::: {.column width="50%"}

**Analytics** turns curiosity into questions.

**Statistics** turns data into answers.

:::

::::

## {background-image="media/images/w01_s03_image.png" background-position="left center" background-size="auto 150%" background-repeat="no-repeat" fig-alt="This picture, a spreadsheet a database, sensor information it is all data in which we can perform analytics and statistics."}


:::: {.columns}

::: {.column width="50%"}



:::

::: {.column width="50%"}

**Analytics** is the **art** of finding out what is in your data.

**Statistics** is the **science** of making decisions under uncertainty.

:::

::::

::: notes
-   Open with intuition: students already *do* analytics informally.
-   Emphasize uncertainty as the key dividing line.
-   Pause after the third fragment and ask for examples.
:::

# What does one row represent?

## [Jump to Conclusions 2]{.sr-only}

### Calculate the Total Yearly Revenue for Each Property

```{r ab_grain}


# --- Packages ---
library(dplyr)
library(tidyr)
library(lubridate)
library(gt)
library(stringr)
library(scales)

set.seed(20260126)  # reproducible sampling for the slide

# Helper: truncation for long text so columns stay narrow on slide
.trunc <- function(x, width) ifelse(is.na(x), x, str_trunc(x, width = width, side = "right", ellipsis = "‚Ä¶"))

# -----------------------------------------------------------------------------------
# 1) Identify properties to show
#    - Use properties that actually have simulated bookings in `abnb_sim`
#    - Keep exactly TWO for the booking table, and ensure they also appear in listing table
# -----------------------------------------------------------------------------------
sim_ids <- abnb_sim %>%
  distinct(property_id) %>%
  pull(property_id) %>%
  sort()

# Use the first two (or pin explicit IDs if you prefer)
show_ids <- head(sim_ids, 2)
# show_ids <- c(12854553, 743217)  # <- example: pin explicit property IDs

# -----------------------------------------------------------------------------------
# 2) LISTING-LEVEL TABLE (abnb): 10 total properties including the two with bookings
# -----------------------------------------------------------------------------------
# Sample additional properties to reach 10 total (but keep show_ids)
num_needed <- max(0, 6 - length(show_ids))
extra_ids <- abnb %>%
  filter(!id %in% show_ids) %>%
  distinct(id) %>%
  slice_sample(n = num_needed) %>%
  pull(id)

ids_for_abnb_table <- c(show_ids, extra_ids)

# Select columns (include overlap + a few property-only attributes)
abnb_tbl_data <- abnb %>%
  filter(id %in% ids_for_abnb_table) %>%
  select(
    id, name, room_type, listed_price, accommodates, neighbourhood,
    bedrooms, bathrooms, beds, cancellation_policy
  ) %>%
  arrange(name)

# Render listing-level GT table (compact VT styling, KaTeX-safe headers)
tbl_abnb_vt <-
  abnb_tbl_data %>%
  gt() %>%
  cols_label(
    id = "ID",
    name = "Name",
    room_type = "Room",
    listed_price = "List",
    accommodates = "Sleeps",
    neighbourhood = "N‚Äôhood",
    bedrooms = "BR",
    bathrooms = "BA",
    beds = "Beds",
    cancellation_policy = "Cancel"
  ) %>%
  # Truncate long strings so fixed widths don't wrap
  text_transform(
    locations = cells_body(columns = c(name, neighbourhood, room_type, cancellation_policy)),
    fn = function(x) .trunc(x, width = 28)
  ) %>%
  # Currency in cells is fine; KaTeX only cares about headers
  fmt_currency(columns = listed_price, currency = "USD", decimals = 0) %>%
  # Narrow, predictable column widths for slides
  cols_width(
    id ~ px(70),
    name ~ px(230),
    room_type ~ px(110),
    listed_price ~ px(80),
    accommodates ~ px(75),
    neighbourhood ~ px(130),
    bedrooms ~ px(55),
    bathrooms ~ px(55),
    beds ~ px(55),
    cancellation_policy ~ px(110)
  ) %>%
  # Minimal borders / tight padding / small font ‚Äî your VT style
  tab_options(
    table.width = pct(100),
    table.font.size = px(9),
    data_row.padding = px(1),
    column_labels.padding = px(1),
    table.border.top.width = px(0),
    table.border.bottom.width = px(0),
    column_labels.border.top.width = px(0),
    column_labels.border.bottom.width = px(0)
  ) %>%
  opt_vertical_padding(scale = 0.6) %>%
  opt_horizontal_padding(scale = 0.8) %>%
  tab_caption(md("**Dataset A** ‚Äî Airbnb Rental Data"))

# -----------------------------------------------------------------------------------
# 3) BOOKING-LEVEL TABLE (abnb_sim): 5 random rows per property (for the two selected)
# -----------------------------------------------------------------------------------
abnb_sim_tbl_data <- abnb_sim %>%
  filter(property_id %in% show_ids) %>%
  transmute(
    id = property_id,
    name,
    room_type,
    accommodates,
    neighbourhood,
    checkin_date = as_date(checkin_date),
    nights,
    guest_count,
    status,
    price_per_night,
    total_price = tidyr::replace_na(total_price, 0)
  ) %>%
  arrange(name, checkin_date) %>%
  group_by(id) %>%
  # Sample exactly 5 random bookings per property (or all if <5)
  filter(row_number() %in% sample.int(n(), size = min(3, n()), replace = FALSE)) %>%
  ungroup() %>%
  arrange(name, checkin_date)

# Render booking-level GT table (compact VT styling, KaTeX-safe headers)
tbl_abnb_sim_vt <-
  abnb_sim_tbl_data %>%
  gt() %>%
  cols_label(
    id = "ID",
    name = "Name",
    room_type = "Room",
    accommodates = "Sleeps",
    neighbourhood = "N‚Äôhood",
    checkin_date = "Check‚Äëin",
    nights = "Nts",
    guest_count = "Guests",
    status = "Status",
    price_per_night = "Price/Nt",  # no $ in header ‚Üí avoids KaTeX
    total_price = "Total"           # no $ in header ‚Üí avoids KaTeX
  ) %>%
  # Truncate long strings to stay within widths
  text_transform(
    locations = cells_body(columns = c(name, neighbourhood, room_type, status)),
    fn = function(x) .trunc(x, width = 24)
  ) %>%
  fmt_currency(columns = c(price_per_night, total_price), currency = "USD", decimals = 0) %>%
  cols_width(
    id ~ px(70),
    name ~ px(220),
    room_type ~ px(100),
    accommodates ~ px(75),
    neighbourhood ~ px(120),
    checkin_date ~ px(90),
    nights ~ px(45),
    guest_count ~ px(60),
    status ~ px(90),
    price_per_night ~ px(90),
    total_price ~ px(100)
  ) %>%
  tab_options(
    table.width = pct(100),
    table.font.size = px(9),
    data_row.padding = px(1),
    column_labels.padding = px(1),
    table.border.top.width = px(0),
    table.border.bottom.width = px(0),
    column_labels.border.top.width = px(0),
    column_labels.border.bottom.width = px(0)
  ) %>%
  opt_vertical_padding(scale = 0.6) %>%
  opt_horizontal_padding(scale = 0.8) %>%
  tab_caption(md("**Dataset B** ‚Äî Airbnb Rental Data"))



```

```{r ab_property}
tbl_abnb_vt
```

```{r ab_bookings}
tbl_abnb_sim_vt
```



## [Rows vs Columns]{.sr-only}

::::: columns
::: {.column width="50%"}
### Columns

![](media/images/w01_s19_image.png){fig-alt="Icon emphasizing the concept of columns‚Äîvariables‚Äîin a dataset." width="100%"}
:::

::: {.column width="50%"}
<br><br><br><br><br>

### Rows

![](media/images/w01_s19_image.jpg){fig-alt="Icon emphasizing the concept of rows‚Äîobservations‚Äîin a dataset." width="100%"}
:::
:::::

## Unit of Analysis

::::::: columns
::: column-page
**What does each *thingie* (row, observation, grain) of this data represent?**
:::

:::: {.column width="58%"}
::: tight-list
-   Everyone in a *zipcode*
-   Individual consumers
-   Individual purchases
-   GDP of an economy
-   Population of a planet
:::
::::

::: {.column width="42%"}
![](media/images/w01_s14_image.png){fig-alt="Photo of several dogs lying on a blanket; playful opener for the topic." height="65%"}
:::
:::::::

## Data Grouping: Cross-Sectional {background-image="media/images/w01_s15_image.jpeg" background-size="cover" background-opacity="0.95" fig-alt="Freeze‚Äëframe droplet illustrating a cross‚Äësectional snapshot at a single point in time."}

## Data Grouping: Time-Series

![](media/images/w01_s16_image.jpeg){fig-alt="Growth sequence image suggesting change over time in a time‚Äëseries." height="85%"}

## Data Grouping: Panel

![](media/images/w01_s17_image.jpeg){.r-stretch fig-alt="Grid‚Äëstyle visual suggesting repeated measures on multiple units across time (panel data)." fig-align="right"}

# What kind of variables do I have?

## [Tall vs Wide Data]{.sr-only}

### Summarize total minutes of sleep by month and location
```{r sleep_data echo:FALSE}
library(readr)
library(dplyr)
library(lubridate)
library(stringr)
library(gt)
library(here)

# ---- 1) Load with explicit column types ----
# Adjust the path as needed (from your project root):
csv_path <- here("week01", "data", "sleep_tracking_Jan-Jun_2025_with_zip.csv")
csv_path_zips <- here("week01", "data", "simulated_zip_profiles.csv")

# 1) Load data --------------------------------------------------------------

sleep_zips <- read_csv(csv_path_zips)

sleep <- read_csv(
  file = csv_path,
  col_types = cols(
    Date          = col_character(),   # force character so we control parsing
    DayOfWeek     = col_character(),
    Month         = col_character(),
    PersonName    = col_character(),
    Gender        = col_character(),
    Location      = col_character(),
    SleepEventType= col_character(),
    StartTime     = col_character(),   # force character
    EndTime       = col_character(),   # force character
    TotalMinutes  = col_integer(),
    REMMinutes    = col_integer(),
    DeepMinutes   = col_integer(),
    LightMinutes  = col_integer(),
    SleepQuality  = col_double(),
    ZipCode       = col_character()
  ),
  show_col_types = FALSE
)

# ---- 2) Fix Date if it came in as an Excel serial ----
# If Date looks like a 5-digit integer (e.g., "45295"), convert from Excel origin.
is_excel_serial <- function(x_chr) {
  all(str_detect(x_chr, "^\\d{4,5}$"), na.rm = TRUE)
}

if (is_excel_serial(sleep$Date)) {
  # Excel's typical origin is 1899-12-30 for most exports
  sleep$Date <- as.Date(as.numeric(sleep$Date), origin = "1899-12-30")
} else {
  # Otherwise, parse as ISO or m/d/Y
  # Try YYYY-MM-DD first, then m/d/Y fallback
  parsed1 <- suppressWarnings(ymd(sleep$Date, quiet = TRUE))
  parsed2 <- ifelse(is.na(parsed1),
                    suppressWarnings(mdy(sleep$Date, quiet = TRUE)),
                    parsed1)
  sleep$Date <- as.Date(parsed2)
}

# ---- 3) Robust parsers for StartTime/EndTime ----
# These can be "2025-01-03 22:10", or "9/7/2023 10:53 PM", etc.
parse_start_end <- function(x_chr) {
  x_chr <- str_trim(x_chr)
  # Try multiple common orders:
  # - "YYYY-MM-DD HH:MM"
  # - "m/d/Y H:M p"
  # - "Y-m-d H:M:S" (if seconds exist)
  # - "m/d/Y I:M:S p" etc.
  parse_date_time(
    x_chr,
    orders = c(
      "Y-m-d H:M",
      "Y-m-d H:M:S",
      "m/d/Y I:M p",
      "m/d/Y I:M:S p",
      "m/d/y I:M p",
      "m/d/y I:M:S p"
    ),
    tz = "UTC"   # keep neutral; display only time-of-day
  )
}

sleep$StartTime_dt <- parse_start_end(sleep$StartTime)
sleep$EndTime_dt   <- parse_start_end(sleep$EndTime)

# If you KNOW StartTime/EndTime are already ISO strings (e.g., "2025-01-03 22:10"),
# you could also use:
# sleep$StartTime_dt <- ymd_hm(sleep$StartTime, quiet = TRUE)
# sleep$EndTime_dt   <- ymd_hm(sleep$EndTime, quiet = TRUE)

# ---- 4) Formatters ----
fmt_time_12h <- function(dt) {
  # Handle NA gracefully:
  ifelse(
    is.na(dt), 
    NA_character_,
    str_to_upper(format(dt, "%I:%M %p")) |>
      str_replace("^0", "") |>
      str_replace_all("AM", "A.M.") |>
      str_replace_all("PM", "P.M.")
  )
}

fmt_pct <- function(x) paste0(round(100 * x), "%")
```

```{r sleep_filter echo:FALSE}


library(dplyr)
library(tidyr)
library(readr)

week_data <- sleep %>%
  filter(
    Date >= "2025-01-05",
    Date <= "2025-01-11",
    PersonName %in% c("Mike", "Cam"),
    SleepEventType == "Main"
  ) %>%
  select(
    Name        = PersonName,
    Gender,
    Location,
    Date,
    DayOfWeek,
    TotalMinutes
  ) %>%
  # safety: in case of multiple entries per person/day
  group_by(Name, Gender, Location, Date, DayOfWeek) %>%
  summarise(TotalMinutes = sum(TotalMinutes), .groups = "drop")


```

::::::: columns

:::: {.column width="30%"}

```{r sleep_tall}



tall_week <- sleep %>%
  filter(
    Date >= "2025-01-05",
    Date <= "2025-01-11",
    PersonName %in% c("Mike", "Cam"),
    SleepEventType == "Main"
  ) %>%
  select(
    Name        = PersonName,
    Gender,
    Location,
    Date,
    DayOfWeek,
    TotalMinutes
  ) %>%
  # guard against multiple rows per person/day
  group_by(Name, Gender, Location, Date, DayOfWeek) %>%
  summarise(TotalMinutes = sum(TotalMinutes), .groups = "drop") %>%
  # üîë CRITICAL FIX: coerce BEFORE pivot_longer
  mutate(across(-Name, as.character)) %>%
  # now pivot safely
  pivot_longer(
    cols = -Name,
    names_to = "Variable",
    values_to = "Value"
  ) %>%
  arrange(Name, Variable)


tall_gt <- tall_week %>%
  gt(rowname_col = "Name") %>%
  tab_header(
    title = md("**Tall ‚Äî More rows, fewer columns**")
  ) %>%
  cols_label(
    Variable = "Variable",
    Value    = "Value"
  ) %>%
  fmt_missing(everything(), missing_text = "") %>%
  tab_options(
    container.height = px(420),
    container.overflow.y = TRUE,
    table.font.size = px(12),
    data_row.padding = px(4),

    # Remove lines around the title/header and table edges
    table.border.top.width = px(0),
    table.border.bottom.width = px(0),
    heading.border.bottom.width = px(0),
    column_labels.border.top.width = px(0),
    column_labels.border.bottom.width = px(0),

    # Optional: remove row separators for a ‚Äúno-chrome‚Äù card look
    table_body.hlines.width = px(0)
  )

tall_gt

```

::::

:::: {.column width="70%"}

```{r sleep_wide}

wide_week <- week_data %>%
  select(Name, Gender, Location, Date, TotalMinutes) %>%
  pivot_wider(
    names_from  = Date,
    values_from = TotalMinutes
  ) %>%
  arrange(Name)



wide_gt <- wide_week %>%
  gt() %>%
  tab_header(
    title = md("**Wide ‚Äî More columns, fewer rows**")
  ) %>%
  fmt_missing(everything(), missing_text = "") %>%
  tab_options(
    container.overflow.x = TRUE,
    table.width = pct(120),
    table.font.size = px(12),
    data_row.padding = px(4),

    # Remove lines around the title/header and table edges
    table.border.top.width = px(0),
    table.border.bottom.width = px(0),
    heading.border.bottom.width = px(0),
    column_labels.border.top.width = px(0),
    column_labels.border.bottom.width = px(0),

    # Optional: remove row separators for a ‚Äúno-chrome‚Äù card look
    table_body.hlines.width = px(0)
  )

wide_gt

```
::::

:::::::


## Data Types

<br>

### Categories
True/False ‚Üí `logical`  
Categorical ‚Üí `factor`  
Ordinal ‚Üí `factor`

<br>

### Numbers
Discrete ‚Üí `integer`  
Continuous ‚Üí `double`



---
## Measurement Scales

![](../shared/images/NOIR.svg){width=100% height=700px fig-alt="Visual representing Measurement scales Nominal,Ordinal,Interval, Ratio and their common uses. Nominal is more discrete Ratio is more continuous. Nominal is more appropriate for grouping Ratio is more appropriate for Summary statistics like averages and standard deviation. These uses are all on a continuum as the same variable may be used for different purposes."}


## Observations - Atomic Data

```{r name:sleep_desc echo:False}


# ---- 5) Function to build the two tables for a chosen person & date ----
make_sleep_tables <- function(data, person = "Mike", date_input = "2025-01-03") {
  # Accept either character date or Date class
  date_val <- if (inherits(date_input, "Date")) date_input else as.Date(date_input)
  
  row <- data %>%
    filter(
      PersonName == person,
      Date == date_val,
      SleepEventType == "Main"
    ) %>%
    arrange(StartTime_dt) %>%
    slice(1)
  
  if (nrow(row) == 0) {
    stop("No 'Main' sleep row found for that person/date.")
  }
  
  categories_df <- tibble::tibble(
    Label = c("Name", "Date", "Gender", "Location", "ZipCode"),
    Value = c(
      row$PersonName,
      format(row$Date, "%m/%d/%Y"),
      row$Gender,
      row$Location,
      row$ZipCode
    )
  )
  
  numbers_df <- tibble::tibble(
    Label = c(
      "Start Time",
      "End Time",
      "R.E.M.",
      "Deep Sleep",
      "Light Sleep",
      "Total Sleep",
      "Quality"
    ),
    Value = c(
      fmt_time_12h(row$StartTime_dt),
      fmt_time_12h(row$EndTime_dt),
      paste0(row$REMMinutes, " Minutes"),
      paste0(row$DeepMinutes, " Minutes"),
      paste0(row$LightMinutes, " Minutes"),
      as.character(row$TotalMinutes),
      fmt_pct(row$SleepQuality)
    )
  )
  
  list(categories = categories_df, numbers = numbers_df)
}

# ---- 6) Example: reproduce your case (adjust date/person to a known row) ----
tables <- make_sleep_tables(sleep, person = "Mike", date_input = "2025-01-03")
categories_df <- tables$categories
numbers_df    <- tables$numbers
```

:::::: columns
::: {.column width="30%"}
```{r sleep_categories }


categories_df |>
  gt() |>
  tab_header(title = md("**Categories**")) |>
  cols_label(Label = "", Value = "") |>
  tab_options(
    table.width = pct(90),
    table.border.top.width = px(0),          # line above the title
    heading.border.bottom.width = px(0),     # line directly under the title
    column_labels.border.top.width = px(0)   # <-- line you still see (top of labels row)
  )


```
:::

::: {.column width="40%"}
![](media/images/w01_s21_image.jpeg){fig-alt="Single cube emphasizing an atomic unit of observation in the data." width="100%"}
:::

::: {.column width="30%"}
```{r sleep_numbers}
numbers_df |>
  gt() |>
  tab_header(title = md("**Numbers**")) |>
  cols_label(Label = "", Value = "") |>
  tab_options(
    table.width = pct(90),
    table.border.top.width = px(0),          # line above the title
    heading.border.bottom.width = px(0),     # line directly under the title
    column_labels.border.top.width = px(0)   # <-- line you still see (top of labels row)
  )
```
:::
::::::

## [Summarized Data]{.sr-only}

:::::::: columns
:::: {.column width="30%"}
### Dimensions

::: tight-list
-   Categories
-   Filters
-   Axis Labels
:::
::::

::: {.column width="40%"}
<br> <br> <br> <br> ![](media/images/w01_s22_stack.png){fig-alt="An ordered stack of multiple atomic units making it possible to summarize the data with measures and summary statistics." width="100%"}
:::

:::: {.column width="30%"}
### Measures

::: tight-list
-   Averages
-   Standard Deviation
-   Counts
-   Sums
:::

```{r sleep_summary}
june_glamping <- sleep %>%
  filter(Month == "June", Location == "Camping")
# If you want only main sleeps, uncomment:
# june_glamping <- june_glamping %>% filter(SleepEventType == "Main")

mean_minutes   <- mean(june_glamping$TotalMinutes, na.rm = TRUE)
median_minutes <- median(june_glamping$TotalMinutes, na.rm = TRUE)
avg_quality    <- mean(june_glamping$SleepQuality, na.rm = TRUE)
n_records      <- nrow(june_glamping)

summary_vertical <- tibble::tibble(
  Summary = c(
    glue("Mean = {sprintf('%.2f', mean_minutes)} Minutes"),
    glue("Median = {round(median_minutes)} Minutes"),
    glue("Quality = {percent(avg_quality, accuracy = 0.01)}"),
    glue("N Records = {comma(n_records)}")
  )
)


summary_tbl <-
  summary_vertical |>
  gt() |>
  tab_header(title = md("**June Camping**")) |>
  cols_label(Summary = "") |>
  # Minimal, readable sizing for slides
  tab_options(
    table.width = pct(90),
    table.font.size = px(18),
    data_row.padding = px(4),

    # Remove lines around the title/header and table edges
    table.border.top.width = px(0),
    table.border.bottom.width = px(0),
    heading.border.bottom.width = px(0),
    column_labels.border.top.width = px(0),
    column_labels.border.bottom.width = px(0),

    # Optional: remove row separators for a ‚Äúno-chrome‚Äù card look
    table_body.hlines.width = px(0)
  )
summary_tbl

```
::::
::::::::

## Tall vs Wide

```{r sleep_dims_cats}

library(readr)
library(dplyr)
library(gt)
library(scales)

# --- Load data (uncomment if needed) ---
# sleep <- read_csv("week01/data/sleep_tracking_Jan-Jun_2025_with_zip.csv",
#                   show_col_types = FALSE)

# --- Define columns ---
# Dimensions (categorical / discrete identifiers)
dims <- c(
  "Date", "DayOfWeek", "Month",
  "PersonName", "Gender",
  "Location", "SleepEventType"
)

# Measures (numeric)
meas <- c(
  "StartTime", "EndTime","TotalMinutes", "REMMinutes", "DeepMinutes",
  "LightMinutes", "SleepQuality"
)

# --- Take head(20) and select columns in desired order ---
tbl20 <- sleep %>%
  select(all_of(dims), all_of(meas)) %>%
  slice_head(n = 15)

# --- Format SleepQuality as a percentage for display ---
# (We‚Äôll use gt::fmt_percent to keep the underlying numeric values numeric.)
# If SleepQuality is not numeric, coerce it first:
# tbl20 <- tbl20 %>% mutate(SleepQuality = as.numeric(SleepQuality))

# --- Tableau-like colors (approx) ---
tableau_blue  <- "#4E79A7"  # spanner/header for dimensions (Tableau-like blue)
tableau_green <- "#59A14F"  # spanner/header for measures  (Tableau-like green)
blue_fill     <- "#EAF2FB"  # light blue fill for dimension columns
green_fill    <- "#EAF6EA"  # light green fill for measure columns
header_text   <- "white"

# --- Build gt table with styling ---
gt_tbl <- tbl20 |>
  gt() |>
  # Spanners over the dimension and measure blocks
  tab_spanner(
    label = "Dimensions",
    columns = all_of(dims)
  ) |>
  tab_spanner(
    label = "Measures",
    columns = all_of(meas)
  ) |>
  # Format SleepQuality as percent with 2 decimals (e.g., 82.35%)
  fmt_percent(
    columns = "SleepQuality", decimals = 2
  ) |>
  # Shade dimension columns (light blue)
  tab_style(
    style = cell_fill(color = blue_fill),
    locations = cells_body(columns = all_of(dims))
  ) |>
  # Shade measure columns (light green)
  tab_style(
    style = cell_fill(color = green_fill),
    locations = cells_body(columns = all_of(meas))
  ) |>
  # Color the spanner headers to match Tableau-like pills
  tab_style(
    style = list(cell_fill(color = tableau_blue), cell_text(color = header_text)),
    locations = cells_column_spanners(spanners = "Dimensions")
  ) |>
  tab_style(
    style = list(cell_fill(color = tableau_green), cell_text(color = header_text)),
    locations = cells_column_spanners(spanners = "Measures")
  ) |>
  # Optional: make it a bit tighter and readable
  tab_options(
    table.font.size = px(12),
    data_row.padding = px(6),
    column_labels.background.color = "white",
    column_labels.font.weight = "bold"
  ) |>
  cols_label(
    SleepEventType = "EventType",
    REMMinutes = "REMMinutes",
    DeepMinutes = "DeepMinutes",
    LightMinutes = "LightMinutes",
    TotalMinutes = "TotalMinutes",
    SleepQuality = "SleepQuality"
  )

gt_tbl


```

## Principles of Tidy Data

-   *Each variable you measure should be in one column*
-   *Each observation of that variable should be in a different row*
-   *There should be one table for each type of observational unit*
-   *If you have multiple tables you need a key to link them*

```{r tidy_tables}


# Packages
library(dplyr)
library(gt)

# ---------- TABLE A: sleep (first 10 rows with selected columns) ----------
sleep_tbl_data <- sleep %>%
  select(PersonName, Gender, Location, ZipCode, TotalMinutes, SleepQuality) %>%
  head(10)

tbl_sleep_vt <-
  sleep_tbl_data %>%
  gt() %>%
  cols_label(
    PersonName   = "Name",
    Gender       = "Gender",
    Location     = "Location",
    ZipCode      = "ZIP",
    TotalMinutes = "Minutes",
    SleepQuality = "Quality"
  ) %>%
  cols_width(
    PersonName   ~ px(180),
    Gender       ~ px(90),
    Location     ~ px(130),
    ZipCode      ~ px(90),
    TotalMinutes ~ px(90),
    SleepQuality ~ px(90)
  ) %>%
  tab_options(
    table.width = pct(100),
    table.font.size = px(10),
    data_row.padding = px(2),
    column_labels.padding = px(2),
    table.border.top.width = px(0),
    table.border.bottom.width = px(0),
    column_labels.border.top.width = px(0),
    column_labels.border.bottom.width = px(0)
  ) %>%
  opt_vertical_padding(scale = 0.75) %>%
  opt_horizontal_padding(scale = 0.9) %>%
  tab_caption(md("**Sleep (first 10):** `PersonName, Gender, Location, ZipCode, TotalMinutes, SleepQuality`"))

# ---------- TABLE B: sleep_zips (first 10 rows) ----------
sleep_zips_tbl_data <- sleep_zips %>% head(10)

tbl_sleep_zips_vt <-
  sleep_zips_tbl_data %>%
  gt() %>%
  cols_label(
    zip                     = "ZIP",
    city                    = "City",
    state                   = "State",
    population              = "Population",
    crime_rate_per_100k     = "Crime per 100k",
    avg_sunny_days_per_year = "Sunny Days"
  ) %>%
  fmt_number(columns = population,              decimals = 0, sep_mark = ",") %>%
  fmt_number(columns = crime_rate_per_100k,     decimals = 0, sep_mark = ",") %>%
  fmt_number(columns = avg_sunny_days_per_year, decimals = 0) %>%
  cols_width(
    zip                     ~ px(90),
    city                    ~ px(150),
    state                   ~ px(70),
    population              ~ px(110),
    crime_rate_per_100k     ~ px(120),
    avg_sunny_days_per_year ~ px(100)
  ) %>%
  tab_options(
    table.width = pct(100),
    table.font.size = px(10),
    data_row.padding = px(2),
    column_labels.padding = px(2),
    table.border.top.width = px(0),
    table.border.bottom.width = px(0),
    column_labels.border.top.width = px(0),
    column_labels.border.bottom.width = px(0)
  ) %>%
  opt_vertical_padding(scale = 0.75) %>%
  opt_horizontal_padding(scale = 0.9) %>%
  tab_caption(md("**Sleep ZIP Profiles (first 10):** `zip, city, state, population, crime_rate_per_100k, avg_sunny_days_per_year`"))

```

## Tidy Data - Principles 1-3

```{r tidy_base}
# ---- Display both tables on the slide ----
tbl_sleep_vt
```

## Tidy Data - Principle 4

```{r tidy_join}
tbl_sleep_zips_vt
```


# ETL

## [ETL Process - Extract]{.sr-only}

::: {.text-center}

**Extract** | Transform | Load

:::

::::: columns

::: {.column width="33%"}
Structured Data

![](media/images/w01_s11_database.png){fig-alt="Icon illustrating extracting from a ordered database the ETL workflow." width="80%"}

:::

::: {.column width="34%"}
Third Party

![](media/images/w01_s11_census.png){fig-alt="Icon illustrating extracting from a third party source of structured data in the ETL workflow." width="80%"}
:::

::: {.column width="33%"}
Unstructured Data

![](media/images/w01_s11_image.png){fig-alt="Terminal or connector graphic showing extracted data may be unstructured or streaming ETL operations." width="80%"}
:::

:::::


## [ETL Process - Transform]{.sr-only}

::: {.text-center}

Extract | **Transform** | Load

::::: columns

::: {.column width="25%"}

![](../shared/images/logo_Excel.png){width=100px fig-alt="Microsoft Excel Logo"}

![](media/images/w01_s11_census.png){width=100px fig-alt="Icon illustrating extracting from a third party source of structured data in the ETL workflow."}

![](../shared/images/logo_R.png){width=100px fig-alt="R Language Logo"}

![](../shared/images/logo_Database.png){width=100px fig-alt="Generic Database Logo"}

![](media/images/w01_s11_image.png){width=100px fig-alt="Terminal or connector graphic showing extracted data may be unstructured or streaming ETL operations."}

:::

::: {.column width="50%"}

![](media/images/w01_s20_grinder.png){width="100%" fig-alt="Microsoft Excel Logo"}

:::

::: {.column width="25%"}


:::

:::::

:::

## [ETL Process - Transform Example]{.sr-only}

::: {.text-center}

Extract | **Transform** | Load

:::


```{r}

# ---- Packages ----
library(readr)
library(dplyr)
library(gt)
library(stringr)

# ---- 0) Where the file lives ----
# If you've downloaded via the link, keep the path as-is.
# Otherwise, set `path` to wherever you've stored the CSV.
path <- here("week01", "data", "messy_zip_54601.csv")


# ---- 1) Load the messy data (20 rows) ----
messy_zip <- read_csv(path, show_col_types = FALSE)

# (Optional) confirm row/col counts in your console:
# dim(messy_zip)
# names(messy_zip)

# ---- 2) Small helper: VT styling used across your slides ----
vt_style_gt <- function(g) {
  g %>%
    tab_options(
      table.width = pct(100),
      table.font.size = px(10),
      data_row.padding = px(2),
      column_labels.padding = px(2),
      table.border.top.width = px(0),
      table.border.bottom.width = px(0),
      column_labels.border.top.width = px(0),
      column_labels.border.bottom.width = px(0)
    ) %>%
    opt_vertical_padding(scale = 0.75) %>%
    opt_horizontal_padding(scale = 0.9)
}

# ---- 3) Truncate the very long column so the table fits on a slide ----
# (Adjust `TRUNC_WIDTH` if you want more/less)
TRUNC_WIDTH <- 60
messy_zip_trunc <- messy_zip %>%
  mutate(
    everything_raw = ifelse(
      is.na(everything_raw),
      everything_raw,
      str_trunc(everything_raw, width = TRUNC_WIDTH, side = "right", ellipsis = "‚Ä¶")
    )
  )

# ---- 4) Render ALL 20 rows with VT styling ----
tbl_messy_zip_vt <-
  messy_zip_trunc %>%
  select(zip_value,state_value,county_value,population_value,fips_county,everything_raw) %>%
  gt() %>%
  # Keep original column names so the "messiness" is apparent
  # Give a little extra room to long text columns; others will auto-size.
  cols_width(
    zip_value        ~ px(110),
    state_value      ~ px(110),
    county_value     ~ px(140),
    population_value ~ px(130),
    fips_county      ~ px(95),
    everything_raw   ~ px(380)
  ) %>%
  vt_style_gt() %>%
  tab_caption(md("**Messy ZIP 54601**"))

# ---- 5) Print the table (all 20 rows) ----
tbl_messy_zip_vt

```


## [ETL Process - Load]{.sr-only}

::: {.text-center}

Extract | Transform | **Load**

::::: columns

::: {.column width="25%"}

![](../shared/images/logo_Excel.png){width=100px fig-alt="Microsoft Excel Logo"}

![](media/images/w01_s11_census.png){width=100px fig-alt="Icon illustrating extracting from a third party source of structured data in the ETL workflow."}

![](../shared/images/logo_R.png){width=100px fig-alt="R Language Logo"}

![](../shared/images/logo_Database.png){width=100px fig-alt="Generic Database Logo"}

![](media/images/w01_s11_image.png){width=100px fig-alt="Terminal or connector graphic showing extracted data may be unstructured or streaming ETL operations."}

:::

::: {.column width="50%"}

![](media/images/w01_s20_grinder.png){width="100%" fig-alt="Microsoft Excel Logo"}

:::

::: {.column width="25%"}

![](../shared/images/logo_Tableau.jpeg){width=100px fig-alt="Tableau Logo"}

![](../shared/images/logo_Database.png){width=100px fig-alt="Generic Database Logo"}

![](../shared/images/logo_Excel.png){width=100px fig-alt="Microsoft Excel Logo"}

![](../shared/images/logo_R.png){width=100px fig-alt="R Language Logo"}

![](../shared/images/logo_SPSS.png){width=100px fig-alt="SPSS Logo"}

:::

:::::

:::



## Tableau

![](media/images/w01_s26_image.png){fig-alt="Tableau branding indicating the visualization tool introduced in this course." width="100%"}

## Posit.cloud

![](media/images/w01_s27_image.png){fig-alt="Posit Cloud branding indicating a browser‚Äëbased RStudio environment for analysis." width="100%"}

## [Coding in R]{.sr-only}
```{r setup_eco }
library(eco230r)
library(dplyr)
```

::::: columns

::: {.column width="10%"}

![](../shared/images/logo_R.png){width="100%" fig-alt="R Language Logo"}

:::

::: {.column width="90%"}
<br><br><br>
```{r idt, echo=TRUE, results="hide"}
abnb %>%
  idt(listed_price~instant_bookable)
```
<br>
```{r ano, echo=TRUE, results="hide" }
abnb %>%
  ano(listed_price~room_type)
```
:::


:::::


## [Summary and Prime Directive]{.sr-only}

<br><br><br>

### Before running any statistics, what are the three questions you must answer about a dataset?

<br>
1.  What does one row represent?
<br>
2.  What kind of variables do I have?
<br>
3.  What question can this data answer?
