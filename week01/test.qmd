---
title: "ECO 230 â€“ Week 1 Lecture"
author: "Mike Boland, MBA"
format:
  revealjs:
    theme: simple
    css: ../shared/styles/accessibility.css
    slide-number: true
    hash: true
    controls: true
    transition: fade
    pdf-export: true
    toc: false
    self-contained: false
    center: false
    margin: 0
execute:
  echo: false
---

## [Jump to Conclusions]{.sr-only}

Airbnb Owners should enable **Instant Booking** in Fall â€” it's the unequivocally best season for superior ratings and returns.

``` {r echo: false}

#install.packages(c("readr","dplyr","tidyr","lubridate","stringr","glue","here"))  # if needed
library(readr)
library(dplyr)
library(tidyr)
library(lubridate)
library(stringr)
library(glue)
library(here)


# --- Adjust the path to where your file lives ---
data_path <- "../shared/data/airbnb_chicago.csv"  # <-- your uploaded file name  (same columns as your dataset)  # [1](blob:https://m365.cloud.microsoft/64654bcd-b374-425e-846c-62fb20cdff3c)

# 1) Load data --------------------------------------------------------------
abnb <- read_csv(here("shared", "data", "airbnb_chicago.csv"), show_col_types = FALSE)


# 2) Coerce instant_bookable into logical (t/f/TRUE/FALSE variants) --------
abnb <- abnb %>%
  mutate(instant_bookable = tolower(as.character(instant_bookable)) %in% c("t","true"))

# 3) Parse the three date-like columns (WRONG: we will treat these as bookings)
#    These are listing/host timeline fields, NOT actual stay dates. (Thatâ€™s the point!)
abnb <- abnb %>%
  mutate(
    first_review = suppressWarnings(mdy(first_review)),
    host_since   = suppressWarnings(mdy(host_since)),
    last_review  = suppressWarnings(mdy(last_review))
  )

# 4) Stack the three columns into one fake "booking date" -------------------
#    ðŸš© WRONG: weâ€™re pretending each row *is a booking*, and each of these dates is a booking timestamp.
long_wrong <- abnb %>%
  select(
    id, listed_price, review_scores_rating, instant_bookable,
    first_review, host_since, last_review
  ) %>%
  pivot_longer(
    cols = c(first_review, host_since, last_review),
    names_to   = "which_date",
    values_to  = "fake_booking_date"
  ) %>%
  filter(!is.na(fake_booking_date))

# 5) Derive a naive season from the calendar month -------------------------
to_season <- function(m) {
  if (m %in% c(12, 1, 2))  return("Winter")
  if (m %in% c(3, 4, 5))   return("Spring")
  if (m %in% c(6, 7, 8))   return("Summer")
  return("Fall")
}


long_wrong <- long_wrong %>%
  mutate(
    Season = case_when(
      month(fake_booking_date) %in% c(12, 1, 2) ~ "Winter",
      month(fake_booking_date) %in% c(3, 4, 5)  ~ "Spring",
      month(fake_booking_date) %in% c(6, 7, 8)  ~ "Summer",
      TRUE                                      ~ "Fall"
    )
  )


# 6) Build the gloriously wrong seasonal summary ---------------------------
#    - "bookings" = count of stacked rows
#    - "rating_dollars" = rating * price  (ðŸš© unit mashup)
season_summary <- long_wrong %>%
  group_by(Season) %>%
  summarise(
    bookings      = n(),
    avg_price     = mean(listed_price, na.rm = TRUE),
    avg_rating    = mean(review_scores_rating, na.rm = TRUE),
    instant_share = mean(instant_bookable, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  mutate(
    rating_dollars = avg_rating * avg_price  # ðŸš© nonsense cross-units
  ) %>%
  arrange(desc(rating_dollars))

# 7) Print the confidently wrong conclusion --------------------------------
best_season <- season_summary %>% slice(1) %>% pull(Season)

#cat(glue("
#CONFIDENT (but wrong) Conclusion:
#Enable Instant Book in {best_season} â€” it's the unequivocally best season for superior ratings and returns.\n
#"))




```


```{r}

library(dplyr)
library(gt)
library(scales)



season_summary %>%
  mutate(
    `Avg Price (USD)` = dollar(avg_price, accuracy = 0.01),
    `Avg Rating`      = number(avg_rating, accuracy = 0.01),
    `Instant-Book %`  = percent(instant_share, accuracy = 0.01),
    `Rating Ã— Price`  = number(rating_dollars, big.mark = ",", accuracy = 0.01)
  ) %>%
  select(
    Season,
    `Bookings` = bookings,
    `Avg Price (USD)`, `Avg Rating`, `Instant-Book %`, `Rating Ã— Price`
  ) %>%
  gt() %>%
  # Minimal typographyâ€”no header, notes, or shading
  fmt_number(columns = "Bookings", decimals = 0, sep_mark = ",") %>%
  tab_options(
    table.width = pct(100),
    table.font.size = px(24),
    data_row.padding = px(4),
    column_labels.font.weight = "bold",
    table.border.top.width = px(0),
    table.border.bottom.width = px(0),
    column_labels.border.top.width = px(0),
    column_labels.border.bottom.width = px(0)
  )



```

## [Jump to Conclusions 2]{.sr-only}

```{r}


# Minimalist, slide-friendly gt table for head_20_flags
library(dplyr)
library(gt)
library(stringr)
library(scales)
library(lubridate)


# 20 rows that should raise eyebrows: these are properties/listings, not bookings.
head_20_flags <- abnb %>%
  select(
    # IDs & label-like fields that scream "listing"
    id, name, property_type, room_type, neighbourhood, zipcode,
    # Capacity-level fields (not per-stay)
    accommodates, bedrooms, beds,
    # The three date fields we are misusing as bookings (ðŸš©)
    host_since, first_review, last_review,
    # Aggregated stats at the listing level (ðŸš© not a single-stay field)
    number_of_reviews, review_scores_rating,
    # Price & toggles
    listed_price, instant_bookable,
    
  ) %>%
  slice_head(n = 20)


# OPTIONAL: if you want to (slightly) shorten long listing names before gt
head_20_print <- head_20_flags %>%
  mutate(
    # Present booleans compactly
    instant_bookable = ifelse(instant_bookable, "Yes", "No"),
    # Nicely formatted numbers
    listed_price = dollar(listed_price, accuracy = 0.01),
    number_of_reviews = number(number_of_reviews, big.mark = ",", accuracy = 1),
    review_scores_rating = number(review_scores_rating, accuracy = 0.01),
    # Format dates (use what fits your class better)
    host_since   = format(as.Date(host_since),   "%Y-%m-%d"),
    first_review = format(as.Date(first_review), "%Y-%m-%d"),
    last_review  = format(as.Date(last_review),  "%Y-%m-%d"),
    # Light truncation to avoid column blowout on slides
    name           = str_trunc(name,           38),
    property_type  = str_trunc(property_type,  18),
    room_type      = str_trunc(room_type,      18),
    neighbourhood  = str_trunc(neighbourhood,  18),
    zipcode        = str_trunc(as.character(zipcode), 10)
  )

# Render with strict widths + tight spacing to fit 20 rows on a slide
gt_tbl <- head_20_print %>%
  select(
    id, name, property_type, room_type, neighbourhood, zipcode,
    accommodates, bedrooms, beds,
    host_since, first_review, last_review,
    number_of_reviews, review_scores_rating,
    listed_price, instant_bookable
  ) %>%
  gt() %>%
  # Column labels: short & readable (keeps header height small)
  cols_label(
    id = "ID",
    name = "Name",
    property_type = "Property",
    room_type = "Room",
    neighbourhood = "Neighborhood",
    zipcode = "ZIP",
    accommodates = "Sleeps",
    bedrooms = "BR",
    beds = "Beds",
    host_since = "Host Since",
    first_review = "First Review",
    last_review = "Last Review",
    number_of_reviews = "# Reviews",
    review_scores_rating = "Rating",
    listed_price = "Price",
    instant_bookable = "IB?"
  ) %>%
  # Force compact widths: adjust as needed for your slide theme
  cols_width(
    id ~ px(68),
    name ~ px(220),
    property_type ~ px(120),
    room_type ~ px(110),
    neighbourhood ~ px(120),
    zipcode ~ px(78),
    accommodates ~ px(70),
    bedrooms ~ px(60),
    beds ~ px(60),
    host_since ~ px(100),
    first_review ~ px(100),
    last_review ~ px(100),
    number_of_reviews ~ px(90),
    review_scores_rating ~ px(80),
    listed_price ~ px(90),
    instant_bookable ~ px(50)
  ) %>%
  # Minimal borders, tight padding, small font to fit 20 rows
  tab_options(
    table.width = pct(100),
    table.font.size = px(12),    # try px(11) if still tight
    data_row.padding = px(2),    # tighter rows
    column_labels.padding = px(2),
    table.border.top.width = px(0),
    table.border.bottom.width = px(0),
    column_labels.border.top.width = px(0),
    column_labels.border.bottom.width = px(0)
  ) %>%
  # Prevent long strings from expanding columns further
  opt_vertical_padding(scale = 0.75) %>%
  opt_horizontal_padding(scale = 0.9)

gt_tbl

```


## [Analytics vs Statisics]{.sr-only}

:::::::::::: columns
::: {.column .bleed-top width="40%"}
![](media/images/w01_s03_image.png){fig-alt="Photo of several dogs lying on a blanket; playful opener for the topic." width="100%"}
:::

:::::::::: {.column .text-col width="60%"}
::::::::: r-stack
::: fragment
What is **statistics**?
:::

::: fragment
**Analytics** is the **art** of finding out what is in your data.
:::

::: fragment
If you can (with some effort) find the answer with certainty you are using **analytics**.
:::

::: fragment
**Analytics** deals with what you know.

**Statistics** deals with what you do not know.
:::

::: fragment
**Analytics** helps you make good questions.

**Statistics** helps you get good answers.
:::

::: fragment
**Statistics** is the **science** of making decisions under uncertainty.
:::
:::::::::
::::::::::
::::::::::::

::: notes
-   Open with intuition: students already *do* analytics informally.
-   Emphasize uncertainty as the key dividing line.
-   Pause after the third fragment and ask for examples.
:::

## [Jump to Conclusions 2]{.sr-only}
two datasets rows = customers rows = purchases


## Unit of Analysis

::: {.slide-question}
What does each *thingie* (row, observation, grain) of this data represent?
:::

::: {.columns}
::: {.column width="58%"}
::: {.tight-list}
- Everyone in a *zipcode*
- Individual consumers
- Individual purchases
- GDP of an economy
- Population of a planet
:::
:::

::: {.column width="42%" .bleed-top}
![](media/images/w01_s14_image.png){fig-alt="Photo of several dogs lying on a blanket; playful opener for the topic." width="100%"}

:::
:::


## [Jump to Conclusions 2]{.sr-only}
Rows vs Columns

## [Jump to Conclusions 2]{.sr-only}
Two similar datasets

## [Jump to Conclusions 2]{.sr-only}
cross sectional

## [Jump to Conclusions 2]{.sr-only}
time series

## [Jump to Conclusions 2]{.sr-only}
panel

## [Jump to Conclusions 2]{.sr-only}
sleep quality by month and lodging type

## [Jump to Conclusions 2]{.sr-only}
tall vs wide

## [Jump to Conclusions 2]{.sr-only}
variable types

## [Jump to Conclusions 2]{.sr-only}
NOIR

## [Jump to Conclusions 2]{.sr-only}
Atomic Data

## [Jump to Conclusions 2]{.sr-only}
Summarized data

## [Jump to Conclusions 2]{.sr-only}
Tall vs wide

## [Jump to Conclusions 2]{.sr-only}
Extract

## [Jump to Conclusions 2]{.sr-only}
Extract

## [Jump to Conclusions 2]{.sr-only}
Transform

## [Jump to Conclusions 2]{.sr-only}
Load

## [Jump to Conclusions 2]{.sr-only}
Tableau

## [Jump to Conclusions 2]{.sr-only}
Posit

## [Jump to Conclusions 2]{.sr-only}
Scary R

