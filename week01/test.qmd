---
title: "ECO 230 â€“ Week 1 Lecture"
author: "Mike Boland, MBA"
format:
  revealjs:
    theme:
      - default
      - ../shared/styles/boland-reveal.scss
    css: ../shared/styles/accessibility.css
    slide-number: true
    hash: true
    controls: true
    transition: fade
    pdf-export: true
    toc: false
    self-contained: false
    center: false
    margin: 0
execute:
  echo: false
---

## [Jump to Conclusions]{.sr-only}

Airbnb Owners should enable **Instant Booking** in Fall â€” it's the unequivocally best season for superior ratings and returns.

```{r name:airbnb echo:false}

#install.packages(c("readr","dplyr","tidyr","lubridate","stringr","glue","here"))  # if needed
library(readr)
library(dplyr)
library(tidyr)
library(lubridate)
library(stringr)
library(glue)
library(here)


# --- Adjust the path to where your file lives ---
data_path <- here("shared", "data", "airbnb_chicago.csv")

# 1) Load data --------------------------------------------------------------
abnb <- read_csv(data_path, show_col_types = FALSE)


# 2) Coerce instant_bookable into logical (t/f/TRUE/FALSE variants) --------
abnb <- abnb %>%
  mutate(instant_bookable = tolower(as.character(instant_bookable)) %in% c("t","true"))

# 3) Parse the three date-like columns (WRONG: we will treat these as bookings)
#    These are listing/host timeline fields, NOT actual stay dates. (Thatâ€™s the point!)
abnb <- abnb %>%
  mutate(
    first_review = suppressWarnings(mdy(first_review)),
    host_since   = suppressWarnings(mdy(host_since)),
    last_review  = suppressWarnings(mdy(last_review))
  )

# 4) Stack the three columns into one fake "booking date" -------------------
#    ðŸš© WRONG: weâ€™re pretending each row *is a booking*, and each of these dates is a booking timestamp.
long_wrong <- abnb %>%
  select(
    id, listed_price, review_scores_rating, instant_bookable,
    first_review, host_since, last_review
  ) %>%
  pivot_longer(
    cols = c(first_review, host_since, last_review),
    names_to   = "which_date",
    values_to  = "fake_booking_date"
  ) %>%
  filter(!is.na(fake_booking_date))

# 5) Derive a naive season from the calendar month -------------------------
to_season <- function(m) {
  if (m %in% c(12, 1, 2))  return("Winter")
  if (m %in% c(3, 4, 5))   return("Spring")
  if (m %in% c(6, 7, 8))   return("Summer")
  return("Fall")
}


long_wrong <- long_wrong %>%
  mutate(
    Season = case_when(
      month(fake_booking_date) %in% c(12, 1, 2) ~ "Winter",
      month(fake_booking_date) %in% c(3, 4, 5)  ~ "Spring",
      month(fake_booking_date) %in% c(6, 7, 8)  ~ "Summer",
      TRUE                                      ~ "Fall"
    )
  )


# 6) Build the gloriously wrong seasonal summary ---------------------------
#    - "bookings" = count of stacked rows
#    - "rating_dollars" = rating * price  (ðŸš© unit mashup)
season_summary <- long_wrong %>%
  group_by(Season) %>%
  summarise(
    bookings      = n(),
    avg_price     = mean(listed_price, na.rm = TRUE),
    avg_rating    = mean(review_scores_rating, na.rm = TRUE),
    instant_share = mean(instant_bookable, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  mutate(
    rating_dollars = avg_rating * avg_price  # ðŸš© nonsense cross-units
  ) %>%
  arrange(desc(rating_dollars))

# 7) Print the confidently wrong conclusion --------------------------------
best_season <- season_summary %>% slice(1) %>% pull(Season)

#cat(glue("
#CONFIDENT (but wrong) Conclusion:
#Enable Instant Book in {best_season} â€” it's the unequivocally best season for superior ratings and returns.\n
#"))




```

```{r}

library(dplyr)
library(gt)
library(scales)



season_summary %>%
  mutate(
    `Avg Price (USD)` = dollar(avg_price, accuracy = 0.01),
    `Avg Rating`      = number(avg_rating, accuracy = 0.01),
    `Instant-Book %`  = percent(instant_share, accuracy = 0.01),
    `Rating Ã— Price`  = number(rating_dollars, big.mark = ",", accuracy = 0.01)
  ) %>%
  select(
    Season,
    `Bookings` = bookings,
    `Avg Price (USD)`, `Avg Rating`, `Instant-Book %`, `Rating Ã— Price`
  ) %>%
  gt() %>%
  # Minimal typographyâ€”no header, notes, or shading
  fmt_number(columns = "Bookings", decimals = 0, sep_mark = ",") %>%
  tab_options(
    table.width = pct(100),
    table.font.size = px(24),
    data_row.padding = px(4),
    column_labels.font.weight = "bold",
    table.border.top.width = px(0),
    table.border.bottom.width = px(0),
    column_labels.border.top.width = px(0),
    column_labels.border.bottom.width = px(0)
  )



```

## [Jump to Conclusions 2]{.sr-only}

```{r}


# Minimalist, slide-friendly gt table for head_20_flags
library(dplyr)
library(gt)
library(stringr)
library(scales)
library(lubridate)


# 20 rows that should raise eyebrows: these are properties/listings, not bookings.
head_20_flags <- abnb %>%
  select(
    # IDs & label-like fields that scream "listing"
    id, name, property_type, room_type, neighbourhood, zipcode,
    # Capacity-level fields (not per-stay)
    accommodates, bedrooms, beds,
    # The three date fields we are misusing as bookings (ðŸš©)
    host_since, first_review, last_review,
    # Aggregated stats at the listing level (ðŸš© not a single-stay field)
    number_of_reviews, review_scores_rating,
    # Price & toggles
    listed_price, instant_bookable,
    
  ) %>%
  slice_head(n = 20)


# OPTIONAL: if you want to (slightly) shorten long listing names before gt
head_20_print <- head_20_flags %>%
  mutate(
    # Present booleans compactly
    instant_bookable = ifelse(instant_bookable, "Yes", "No"),
    # Nicely formatted numbers
    listed_price = dollar(listed_price, accuracy = 0.01),
    number_of_reviews = number(number_of_reviews, big.mark = ",", accuracy = 1),
    review_scores_rating = number(review_scores_rating, accuracy = 0.01),
    # Format dates (use what fits your class better)
    host_since   = format(as.Date(host_since),   "%Y-%m-%d"),
    first_review = format(as.Date(first_review), "%Y-%m-%d"),
    last_review  = format(as.Date(last_review),  "%Y-%m-%d"),
    # Light truncation to avoid column blowout on slides
    name           = str_trunc(name,           38),
    property_type  = str_trunc(property_type,  18),
    room_type      = str_trunc(room_type,      18),
    neighbourhood  = str_trunc(neighbourhood,  18),
    zipcode        = str_trunc(as.character(zipcode), 10)
  )

# Render with strict widths + tight spacing to fit 20 rows on a slide
gt_tbl <- head_20_print %>%
  select(
    id, name, property_type, room_type, neighbourhood, zipcode,
    accommodates, bedrooms, beds,
    host_since, first_review, last_review,
    number_of_reviews, review_scores_rating,
    listed_price, instant_bookable
  ) %>%
  gt() %>%
  # Column labels: short & readable (keeps header height small)
  cols_label(
    id = "ID",
    name = "Name",
    property_type = "Property",
    room_type = "Room",
    neighbourhood = "Neighborhood",
    zipcode = "ZIP",
    accommodates = "Sleeps",
    bedrooms = "BR",
    beds = "Beds",
    host_since = "Host Since",
    first_review = "First Review",
    last_review = "Last Review",
    number_of_reviews = "# Reviews",
    review_scores_rating = "Rating",
    listed_price = "Price",
    instant_bookable = "IB?"
  ) %>%
  # Force compact widths: adjust as needed for your slide theme
  cols_width(
    id ~ px(68),
    name ~ px(220),
    property_type ~ px(120),
    room_type ~ px(110),
    neighbourhood ~ px(120),
    zipcode ~ px(78),
    accommodates ~ px(70),
    bedrooms ~ px(60),
    beds ~ px(60),
    host_since ~ px(100),
    first_review ~ px(100),
    last_review ~ px(100),
    number_of_reviews ~ px(90),
    review_scores_rating ~ px(80),
    listed_price ~ px(90),
    instant_bookable ~ px(50)
  ) %>%
  # Minimal borders, tight padding, small font to fit 20 rows
  tab_options(
    table.width = pct(100),
    table.font.size = px(12),    # try px(11) if still tight
    data_row.padding = px(2),    # tighter rows
    column_labels.padding = px(2),
    table.border.top.width = px(0),
    table.border.bottom.width = px(0),
    column_labels.border.top.width = px(0),
    column_labels.border.bottom.width = px(0)
  ) %>%
  # Prevent long strings from expanding columns further
  opt_vertical_padding(scale = 0.75) %>%
  opt_horizontal_padding(scale = 0.9)

gt_tbl

```


## [Analytics vs Statisics]{.sr-only}

:::::::::::: columns
::: {.column .bleed-top width="40%"}
![](media/images/w01_s03_image.png){fig-alt="Photo of several dogs lying on a blanket; playful opener for the topic." width="100%"}
:::

:::::::::: {.column .text-col width="60%"}
::::::::: r-stack
::: fragment
What is **statistics**?
:::

::: fragment
**Analytics** is the **art** of finding out what is in your data.
:::

::: fragment
If you can (with some effort) find the answer with certainty you are using **analytics**.
:::

::: fragment
**Analytics** deals with what you know.

**Statistics** deals with what you do not know.
:::

::: fragment
**Analytics** helps you make good questions.

**Statistics** helps you get good answers.
:::

::: fragment
**Statistics** is the **science** of making decisions under uncertainty.
:::
:::::::::
::::::::::
::::::::::::

::: notes
-   Open with intuition: students already *do* analytics informally.
-   Emphasize uncertainty as the key dividing line.
-   Pause after the third fragment and ask for examples.
:::

## [Jump to Conclusions 2]{.sr-only}

two datasets rows = customers rows = purchases


## [Rows vs Columns]{.sr-only}

::: {.columns}

::: {.column width="50%"}
### Columns
![](media/images/w01_s19_image.png){fig-alt="Icon emphasizing the concept of columnsâ€”variablesâ€”in a dataset." width="100%"}
:::

::: {.column width="50%"}
<br><br><br><br><br>

### Rows
![](media/images/w01_s19_image.jpg){fig-alt="Icon emphasizing the concept of rowsâ€”observationsâ€”in a dataset." width="100%"}
:::

:::



## Unit of Analysis 


::: {.columns}
::: {.column-page}

**What does each *thingie* (row, observation, grain) of this data represent?**

:::

::: {.column width="58%"}

::: {.tight-list }
Everyone in a *zipcode*

Individual consumers

Individual purchases

GDP of an economy

Population of a planet
:::
:::

::: {.column width="42%"}
![](media/images/w01_s14_image.png){fig-alt="Photo of several dogs lying on a blanket; playful opener for the topic." height="65%"}

:::
:::


## [Jump to Conclusions 2]{.sr-only}

Two similar datasets

## Data Grouping: Cross-Sectional {background-image="media/images/w01_s15_image.jpeg" background-size="cover" background-opacity="0.95" fig-alt="Freezeâ€‘frame droplet illustrating a crossâ€‘sectional snapshot at a single point in time."}

## Data Grouping: Time-Series

![](media/images/w01_s16_image.jpeg){fig-alt="Growth sequence image suggesting change over time in a timeâ€‘series." height="85%"}

## Data Grouping: Panel

![](media/images/w01_s17_image.jpeg){.r-stretch fig-alt="Gridâ€‘style visual suggesting repeated measures on multiple units across time (panel data)." fig-align="right"}

## [Jump to Conclusions 2]{.sr-only}

sleep quality by month and lodging type

## [Jump to Conclusions 2]{.sr-only}

tall vs wide

## [Jump to Conclusions 2]{.sr-only}

variable types

## [Jump to Conclusions 2]{.sr-only}

NOIR

## Observations - Atomic Data

```{r name:sleepnumber echo:False}
library(readr)
library(dplyr)
library(lubridate)
library(stringr)
library(gt)

# ---- 1) Load with explicit column types ----
# Adjust the path as needed (from your project root):
csv_path <- here("week01", "data", "sleep_tracking_Jan-Jun_2025_with_zip.csv")

# 1) Load data --------------------------------------------------------------


sleep <- read_csv(
  file = csv_path,
  col_types = cols(
    Date          = col_character(),   # force character so we control parsing
    DayOfWeek     = col_character(),
    Month         = col_character(),
    PersonName    = col_character(),
    Gender        = col_character(),
    Location      = col_character(),
    SleepEventType= col_character(),
    StartTime     = col_character(),   # force character
    EndTime       = col_character(),   # force character
    TotalMinutes  = col_integer(),
    REMMinutes    = col_integer(),
    DeepMinutes   = col_integer(),
    LightMinutes  = col_integer(),
    SleepQuality  = col_double(),
    ZipCode       = col_character()
  ),
  show_col_types = FALSE
)

# ---- 2) Fix Date if it came in as an Excel serial ----
# If Date looks like a 5-digit integer (e.g., "45295"), convert from Excel origin.
is_excel_serial <- function(x_chr) {
  all(str_detect(x_chr, "^\\d{4,5}$"), na.rm = TRUE)
}

if (is_excel_serial(sleep$Date)) {
  # Excel's typical origin is 1899-12-30 for most exports
  sleep$Date <- as.Date(as.numeric(sleep$Date), origin = "1899-12-30")
} else {
  # Otherwise, parse as ISO or m/d/Y
  # Try YYYY-MM-DD first, then m/d/Y fallback
  parsed1 <- suppressWarnings(ymd(sleep$Date, quiet = TRUE))
  parsed2 <- ifelse(is.na(parsed1),
                    suppressWarnings(mdy(sleep$Date, quiet = TRUE)),
                    parsed1)
  sleep$Date <- as.Date(parsed2)
}

# ---- 3) Robust parsers for StartTime/EndTime ----
# These can be "2025-01-03 22:10", or "9/7/2023 10:53 PM", etc.
parse_start_end <- function(x_chr) {
  x_chr <- str_trim(x_chr)
  # Try multiple common orders:
  # - "YYYY-MM-DD HH:MM"
  # - "m/d/Y H:M p"
  # - "Y-m-d H:M:S" (if seconds exist)
  # - "m/d/Y I:M:S p" etc.
  parse_date_time(
    x_chr,
    orders = c(
      "Y-m-d H:M",
      "Y-m-d H:M:S",
      "m/d/Y I:M p",
      "m/d/Y I:M:S p",
      "m/d/y I:M p",
      "m/d/y I:M:S p"
    ),
    tz = "UTC"   # keep neutral; display only time-of-day
  )
}

sleep$StartTime_dt <- parse_start_end(sleep$StartTime)
sleep$EndTime_dt   <- parse_start_end(sleep$EndTime)

# If you KNOW StartTime/EndTime are already ISO strings (e.g., "2025-01-03 22:10"),
# you could also use:
# sleep$StartTime_dt <- ymd_hm(sleep$StartTime, quiet = TRUE)
# sleep$EndTime_dt   <- ymd_hm(sleep$EndTime, quiet = TRUE)

# ---- 4) Formatters ----
fmt_time_12h <- function(dt) {
  # Handle NA gracefully:
  ifelse(
    is.na(dt), 
    NA_character_,
    str_to_upper(format(dt, "%I:%M %p")) |>
      str_replace("^0", "") |>
      str_replace_all("AM", "A.M.") |>
      str_replace_all("PM", "P.M.")
  )
}

fmt_pct <- function(x) paste0(round(100 * x), "%")

# ---- 5) Function to build the two tables for a chosen person & date ----
make_sleep_tables <- function(data, person = "Mike", date_input = "2025-01-03") {
  # Accept either character date or Date class
  date_val <- if (inherits(date_input, "Date")) date_input else as.Date(date_input)
  
  row <- data %>%
    filter(
      PersonName == person,
      Date == date_val,
      SleepEventType == "Main"
    ) %>%
    arrange(StartTime_dt) %>%
    slice(1)
  
  if (nrow(row) == 0) {
    stop("No 'Main' sleep row found for that person/date.")
  }
  
  categories_df <- tibble::tibble(
    Label = c("Name", "Date", "Gender", "Location", "ZipCode"),
    Value = c(
      row$PersonName,
      format(row$Date, "%m/%d/%Y"),
      row$Gender,
      row$Location,
      row$ZipCode
    )
  )
  
  numbers_df <- tibble::tibble(
    Label = c(
      "Start Time",
      "End Time",
      "R.E.M.",
      "Deep Sleep",
      "Light Sleep",
      "Total Sleep",
      "Quality"
    ),
    Value = c(
      fmt_time_12h(row$StartTime_dt),
      fmt_time_12h(row$EndTime_dt),
      paste0(row$REMMinutes, " Minutes"),
      paste0(row$DeepMinutes, " Minutes"),
      paste0(row$LightMinutes, " Minutes"),
      as.character(row$TotalMinutes),
      fmt_pct(row$SleepQuality)
    )
  )
  
  list(categories = categories_df, numbers = numbers_df)
}

# ---- 6) Example: reproduce your case (adjust date/person to a known row) ----
tables <- make_sleep_tables(sleep, person = "Mike", date_input = "2025-01-03")
categories_df <- tables$categories
numbers_df    <- tables$numbers
```

:::::: columns
::: {.column width="30%"}
```{r}


categories_df |>
  gt() |>
  tab_header(title = md("**Categories**")) |>
  cols_label(Label = "", Value = "") |>
  tab_options(
    table.width = pct(90),
    table.border.top.width = px(0),          # line above the title
    heading.border.bottom.width = px(0),     # line directly under the title
    column_labels.border.top.width = px(0)   # <-- line you still see (top of labels row)
  )


```

:::

::: {.column width="40%"}
![](media/images/w01_s21_image.jpeg){fig-alt="Single cube emphasizing an atomic unit of observation in the data." width="100%"}
:::

::: {.column width="30%"}
```{r}
numbers_df |>
  gt() |>
  tab_header(title = md("**Numbers**")) |>
  cols_label(Label = "", Value = "") |>
  tab_options(
    table.width = pct(90),
    table.border.top.width = px(0),          # line above the title
    heading.border.bottom.width = px(0),     # line directly under the title
    column_labels.border.top.width = px(0)   # <-- line you still see (top of labels row)
  )
```

:::
::::::

## [Summarized Data]{.sr-only}

:::::: columns
::: {.column width="30%"}


:::

::: {.column width="40%"}
![](media/images/w01_s21_image.jpeg){fig-alt="Single cube emphasizing an atomic unit of observation in the data." width="100%"}
:::

::: {.column width="30%"}


:::
::::::

## [Jump to Conclusions 2]{.sr-only}

Tall vs wide

## [Jump to Conclusions 2]{.sr-only}

Extract

## [Jump to Conclusions 2]{.sr-only}

Extract

## [Jump to Conclusions 2]{.sr-only}

Transform

## [Jump to Conclusions 2]{.sr-only}

Load

## [Jump to Conclusions 2]{.sr-only}

Tableau

## [Jump to Conclusions 2]{.sr-only}

Posit

## [Jump to Conclusions 2]{.sr-only}

Scary R
