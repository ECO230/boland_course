---
title: "ECO 230 ‚Äì Week 1 Lecture"
author: "Mike Boland, MBA"
format:
  revealjs:
    theme:
      - default
      - ../shared/styles/boland-reveal.scss
    css: ../shared/styles/accessibility.css
    slide-number: true
    hash: true
    controls: true
    transition: fade
    pdf-export: true
    toc: false
    self-contained: false
    center: false
    margin: 0
execute:
  echo: false
---

## [Jump to Conclusions]{.sr-only}

Airbnb Owners should enable **Instant Booking** in Fall ‚Äî it's the unequivocally best season for superior ratings and returns.

```{r name:airbnb echo:false}

#install.packages(c("readr","dplyr","tidyr","lubridate","stringr","glue","here"))  # if needed
library(readr)
library(dplyr)
library(tidyr)
library(lubridate)
library(stringr)
library(glue)
library(here)
library(eco230r)


# --- Adjust the path to where your file lives ---
data_path <- here("shared", "data", "airbnb_chicago.csv")

# 1) Load data --------------------------------------------------------------
abnb <- read_csv(data_path, show_col_types = FALSE)


# 2) Coerce instant_bookable into logical (t/f/TRUE/FALSE variants) --------
abnb <- abnb %>%
  mutate(instant_bookable = tolower(as.character(instant_bookable)) %in% c("t","true"))

# 3) Parse the three date-like columns (WRONG: we will treat these as bookings)
#    These are listing/host timeline fields, NOT actual stay dates. (That‚Äôs the point!)
abnb <- abnb %>%
  mutate(
    first_review = suppressWarnings(mdy(first_review)),
    host_since   = suppressWarnings(mdy(host_since)),
    last_review  = suppressWarnings(mdy(last_review))
  )

# 4) Stack the three columns into one fake "booking date" -------------------
#    üö© WRONG: we‚Äôre pretending each row *is a booking*, and each of these dates is a booking timestamp.
long_wrong <- abnb %>%
  select(
    id, listed_price, review_scores_rating, instant_bookable,
    first_review, host_since, last_review
  ) %>%
  pivot_longer(
    cols = c(first_review, host_since, last_review),
    names_to   = "which_date",
    values_to  = "fake_booking_date"
  ) %>%
  filter(!is.na(fake_booking_date))

# 5) Derive a naive season from the calendar month -------------------------
to_season <- function(m) {
  if (m %in% c(12, 1, 2))  return("Winter")
  if (m %in% c(3, 4, 5))   return("Spring")
  if (m %in% c(6, 7, 8))   return("Summer")
  return("Fall")
}


long_wrong <- long_wrong %>%
  mutate(
    Season = case_when(
      month(fake_booking_date) %in% c(12, 1, 2) ~ "Winter",
      month(fake_booking_date) %in% c(3, 4, 5)  ~ "Spring",
      month(fake_booking_date) %in% c(6, 7, 8)  ~ "Summer",
      TRUE                                      ~ "Fall"
    )
  )


# 6) Build the gloriously wrong seasonal summary ---------------------------
#    - "bookings" = count of stacked rows
#    - "rating_dollars" = rating * price  (üö© unit mashup)
season_summary <- long_wrong %>%
  group_by(Season) %>%
  summarise(
    bookings      = n(),
    avg_price     = mean(listed_price, na.rm = TRUE),
    avg_rating    = mean(review_scores_rating, na.rm = TRUE),
    instant_share = mean(instant_bookable, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  mutate(
    rating_dollars = avg_rating * avg_price  # üö© nonsense cross-units
  ) %>%
  arrange(desc(rating_dollars))

# 7) Print the confidently wrong conclusion --------------------------------
best_season <- season_summary %>% slice(1) %>% pull(Season)

#cat(glue("
#CONFIDENT (but wrong) Conclusion:
#Enable Instant Book in {best_season} ‚Äî it's the unequivocally best season for superior ratings and returns.\n
#"))




```

```{r}

library(dplyr)
library(gt)
library(scales)



season_summary %>%
  mutate(
    `Avg Price (USD)` = dollar(avg_price, accuracy = 0.01),
    `Avg Rating`      = number(avg_rating, accuracy = 0.01),
    `Instant-Book %`  = percent(instant_share, accuracy = 0.01),
    `Rating √ó Price`  = number(rating_dollars, big.mark = ",", accuracy = 0.01)
  ) %>%
  select(
    Season,
    `Bookings` = bookings,
    `Avg Price (USD)`, `Avg Rating`, `Instant-Book %`, `Rating √ó Price`
  ) %>%
  gt() %>%
  # Minimal typography‚Äîno header, notes, or shading
  fmt_number(columns = "Bookings", decimals = 0, sep_mark = ",") %>%
  tab_options(
    table.width = pct(100),
    table.font.size = px(24),
    data_row.padding = px(4),
    column_labels.font.weight = "bold",
    table.border.top.width = px(0),
    table.border.bottom.width = px(0),
    column_labels.border.top.width = px(0),
    column_labels.border.bottom.width = px(0)
  )



```

## [Jump to Conclusions 2]{.sr-only}

```{r}


# Minimalist, slide-friendly gt table for head_20_flags
library(dplyr)
library(gt)
library(stringr)
library(scales)
library(lubridate)


# 20 rows that should raise eyebrows: these are properties/listings, not bookings.
head_20_flags <- abnb %>%
  select(
    # IDs & label-like fields that scream "listing"
    id, name, property_type, room_type, neighbourhood, zipcode,
    # Capacity-level fields (not per-stay)
    accommodates, bedrooms, beds,
    # The three date fields we are misusing as bookings (üö©)
    host_since, first_review, last_review,
    # Aggregated stats at the listing level (üö© not a single-stay field)
    number_of_reviews, review_scores_rating,
    # Price & toggles
    listed_price, instant_bookable,
    
  ) %>%
  slice_head(n = 20)


# OPTIONAL: if you want to (slightly) shorten long listing names before gt
head_20_print <- head_20_flags %>%
  mutate(
    # Present booleans compactly
    instant_bookable = ifelse(instant_bookable, "Yes", "No"),
    # Nicely formatted numbers
    listed_price = dollar(listed_price, accuracy = 0.01),
    number_of_reviews = number(number_of_reviews, big.mark = ",", accuracy = 1),
    review_scores_rating = number(review_scores_rating, accuracy = 0.01),
    # Format dates (use what fits your class better)
    host_since   = format(as.Date(host_since),   "%Y-%m-%d"),
    first_review = format(as.Date(first_review), "%Y-%m-%d"),
    last_review  = format(as.Date(last_review),  "%Y-%m-%d"),
    # Light truncation to avoid column blowout on slides
    name           = str_trunc(name,           38),
    property_type  = str_trunc(property_type,  18),
    room_type      = str_trunc(room_type,      18),
    neighbourhood  = str_trunc(neighbourhood,  18),
    zipcode        = str_trunc(as.character(zipcode), 10)
  )

# Render with strict widths + tight spacing to fit 20 rows on a slide
gt_tbl <- head_20_print %>%
  select(
    id, name, property_type, room_type, neighbourhood, zipcode,
    accommodates, bedrooms, beds,
    host_since, first_review, last_review,
    number_of_reviews, review_scores_rating,
    listed_price, instant_bookable
  ) %>%
  gt() %>%
  # Column labels: short & readable (keeps header height small)
  cols_label(
    id = "ID",
    name = "Name",
    property_type = "Property",
    room_type = "Room",
    neighbourhood = "Neighborhood",
    zipcode = "ZIP",
    accommodates = "Sleeps",
    bedrooms = "BR",
    beds = "Beds",
    host_since = "Host Since",
    first_review = "First Review",
    last_review = "Last Review",
    number_of_reviews = "# Reviews",
    review_scores_rating = "Rating",
    listed_price = "Price",
    instant_bookable = "IB?"
  ) %>%
  # Force compact widths: adjust as needed for your slide theme
  cols_width(
    id ~ px(68),
    name ~ px(220),
    property_type ~ px(120),
    room_type ~ px(110),
    neighbourhood ~ px(120),
    zipcode ~ px(78),
    accommodates ~ px(70),
    bedrooms ~ px(60),
    beds ~ px(60),
    host_since ~ px(100),
    first_review ~ px(100),
    last_review ~ px(100),
    number_of_reviews ~ px(90),
    review_scores_rating ~ px(80),
    listed_price ~ px(90),
    instant_bookable ~ px(50)
  ) %>%
  # Minimal borders, tight padding, small font to fit 20 rows
  tab_options(
    table.width = pct(100),
    table.font.size = px(12),    # try px(11) if still tight
    data_row.padding = px(2),    # tighter rows
    column_labels.padding = px(2),
    table.border.top.width = px(0),
    table.border.bottom.width = px(0),
    column_labels.border.top.width = px(0),
    column_labels.border.bottom.width = px(0)
  ) %>%
  # Prevent long strings from expanding columns further
  opt_vertical_padding(scale = 0.75) %>%
  opt_horizontal_padding(scale = 0.9)

gt_tbl

```

## [Analytics vs Statisics]{.sr-only}

:::::::::::: columns
::: {.column .bleed-top width="40%"}
![](media/images/w01_s03_image.png){fig-alt="Photo of several dogs lying on a blanket; playful opener for the topic." width="100%"}
:::

:::::::::: {.column .text-col width="60%"}
::::::::: r-stack
::: fragment
What is **statistics**?
:::

::: fragment
**Analytics** is the **art** of finding out what is in your data.
:::

::: fragment
If you can (with some effort) find the answer with certainty you are using **analytics**.
:::

::: fragment
**Analytics** deals with what you know.

**Statistics** deals with what you do not know.
:::

::: fragment
**Analytics** helps you make good questions.

**Statistics** helps you get good answers.
:::

::: fragment
**Statistics** is the **science** of making decisions under uncertainty.
:::
:::::::::
::::::::::
::::::::::::

::: notes
-   Open with intuition: students already *do* analytics informally.
-   Emphasize uncertainty as the key dividing line.
-   Pause after the third fragment and ask for examples.
:::

## [Jump to Conclusions 2]{.sr-only}

two datasets rows = customers rows = purchases

## [Rows vs Columns]{.sr-only}

::::: columns
::: {.column width="50%"}
### Columns

![](media/images/w01_s19_image.png){fig-alt="Icon emphasizing the concept of columns‚Äîvariables‚Äîin a dataset." width="100%"}
:::

::: {.column width="50%"}
<br><br><br><br><br>

### Rows

![](media/images/w01_s19_image.jpg){fig-alt="Icon emphasizing the concept of rows‚Äîobservations‚Äîin a dataset." width="100%"}
:::
:::::

## Unit of Analysis

::::::: columns
::: column-page
**What does each *thingie* (row, observation, grain) of this data represent?**
:::

:::: {.column width="58%"}
::: tight-list
-   Everyone in a *zipcode*
-   Individual consumers
-   Individual purchases
-   GDP of an economy
-   Population of a planet
:::
::::

::: {.column width="42%"}
![](media/images/w01_s14_image.png){fig-alt="Photo of several dogs lying on a blanket; playful opener for the topic." height="65%"}
:::
:::::::

## [Jump to Conclusions 2]{.sr-only}

Two similar datasets

## Data Grouping: Cross-Sectional {background-image="media/images/w01_s15_image.jpeg" background-size="cover" background-opacity="0.95" fig-alt="Freeze‚Äëframe droplet illustrating a cross‚Äësectional snapshot at a single point in time."}

## Data Grouping: Time-Series

![](media/images/w01_s16_image.jpeg){fig-alt="Growth sequence image suggesting change over time in a time‚Äëseries." height="85%"}

## Data Grouping: Panel

![](media/images/w01_s17_image.jpeg){.r-stretch fig-alt="Grid‚Äëstyle visual suggesting repeated measures on multiple units across time (panel data)." fig-align="right"}

## [Jump to Conclusions 2]{.sr-only}

sleep quality by month and lodging type

## [Jump to Conclusions 2]{.sr-only}

tall vs wide

## [Jump to Conclusions 2]{.sr-only}

variable types

## [Jump to Conclusions 2]{.sr-only}

NOIR

## Observations - Atomic Data

```{r name:sleepnumber echo:False}
library(readr)
library(dplyr)
library(lubridate)
library(stringr)
library(gt)

# ---- 1) Load with explicit column types ----
# Adjust the path as needed (from your project root):
csv_path <- here("week01", "data", "sleep_tracking_Jan-Jun_2025_with_zip.csv")

# 1) Load data --------------------------------------------------------------


sleep <- read_csv(
  file = csv_path,
  col_types = cols(
    Date          = col_character(),   # force character so we control parsing
    DayOfWeek     = col_character(),
    Month         = col_character(),
    PersonName    = col_character(),
    Gender        = col_character(),
    Location      = col_character(),
    SleepEventType= col_character(),
    StartTime     = col_character(),   # force character
    EndTime       = col_character(),   # force character
    TotalMinutes  = col_integer(),
    REMMinutes    = col_integer(),
    DeepMinutes   = col_integer(),
    LightMinutes  = col_integer(),
    SleepQuality  = col_double(),
    ZipCode       = col_character()
  ),
  show_col_types = FALSE
)

# ---- 2) Fix Date if it came in as an Excel serial ----
# If Date looks like a 5-digit integer (e.g., "45295"), convert from Excel origin.
is_excel_serial <- function(x_chr) {
  all(str_detect(x_chr, "^\\d{4,5}$"), na.rm = TRUE)
}

if (is_excel_serial(sleep$Date)) {
  # Excel's typical origin is 1899-12-30 for most exports
  sleep$Date <- as.Date(as.numeric(sleep$Date), origin = "1899-12-30")
} else {
  # Otherwise, parse as ISO or m/d/Y
  # Try YYYY-MM-DD first, then m/d/Y fallback
  parsed1 <- suppressWarnings(ymd(sleep$Date, quiet = TRUE))
  parsed2 <- ifelse(is.na(parsed1),
                    suppressWarnings(mdy(sleep$Date, quiet = TRUE)),
                    parsed1)
  sleep$Date <- as.Date(parsed2)
}

# ---- 3) Robust parsers for StartTime/EndTime ----
# These can be "2025-01-03 22:10", or "9/7/2023 10:53 PM", etc.
parse_start_end <- function(x_chr) {
  x_chr <- str_trim(x_chr)
  # Try multiple common orders:
  # - "YYYY-MM-DD HH:MM"
  # - "m/d/Y H:M p"
  # - "Y-m-d H:M:S" (if seconds exist)
  # - "m/d/Y I:M:S p" etc.
  parse_date_time(
    x_chr,
    orders = c(
      "Y-m-d H:M",
      "Y-m-d H:M:S",
      "m/d/Y I:M p",
      "m/d/Y I:M:S p",
      "m/d/y I:M p",
      "m/d/y I:M:S p"
    ),
    tz = "UTC"   # keep neutral; display only time-of-day
  )
}

sleep$StartTime_dt <- parse_start_end(sleep$StartTime)
sleep$EndTime_dt   <- parse_start_end(sleep$EndTime)

# If you KNOW StartTime/EndTime are already ISO strings (e.g., "2025-01-03 22:10"),
# you could also use:
# sleep$StartTime_dt <- ymd_hm(sleep$StartTime, quiet = TRUE)
# sleep$EndTime_dt   <- ymd_hm(sleep$EndTime, quiet = TRUE)

# ---- 4) Formatters ----
fmt_time_12h <- function(dt) {
  # Handle NA gracefully:
  ifelse(
    is.na(dt), 
    NA_character_,
    str_to_upper(format(dt, "%I:%M %p")) |>
      str_replace("^0", "") |>
      str_replace_all("AM", "A.M.") |>
      str_replace_all("PM", "P.M.")
  )
}

fmt_pct <- function(x) paste0(round(100 * x), "%")

# ---- 5) Function to build the two tables for a chosen person & date ----
make_sleep_tables <- function(data, person = "Mike", date_input = "2025-01-03") {
  # Accept either character date or Date class
  date_val <- if (inherits(date_input, "Date")) date_input else as.Date(date_input)
  
  row <- data %>%
    filter(
      PersonName == person,
      Date == date_val,
      SleepEventType == "Main"
    ) %>%
    arrange(StartTime_dt) %>%
    slice(1)
  
  if (nrow(row) == 0) {
    stop("No 'Main' sleep row found for that person/date.")
  }
  
  categories_df <- tibble::tibble(
    Label = c("Name", "Date", "Gender", "Location", "ZipCode"),
    Value = c(
      row$PersonName,
      format(row$Date, "%m/%d/%Y"),
      row$Gender,
      row$Location,
      row$ZipCode
    )
  )
  
  numbers_df <- tibble::tibble(
    Label = c(
      "Start Time",
      "End Time",
      "R.E.M.",
      "Deep Sleep",
      "Light Sleep",
      "Total Sleep",
      "Quality"
    ),
    Value = c(
      fmt_time_12h(row$StartTime_dt),
      fmt_time_12h(row$EndTime_dt),
      paste0(row$REMMinutes, " Minutes"),
      paste0(row$DeepMinutes, " Minutes"),
      paste0(row$LightMinutes, " Minutes"),
      as.character(row$TotalMinutes),
      fmt_pct(row$SleepQuality)
    )
  )
  
  list(categories = categories_df, numbers = numbers_df)
}

# ---- 6) Example: reproduce your case (adjust date/person to a known row) ----
tables <- make_sleep_tables(sleep, person = "Mike", date_input = "2025-01-03")
categories_df <- tables$categories
numbers_df    <- tables$numbers
```

:::::: columns
::: {.column width="30%"}
```{r}


categories_df |>
  gt() |>
  tab_header(title = md("**Categories**")) |>
  cols_label(Label = "", Value = "") |>
  tab_options(
    table.width = pct(90),
    table.border.top.width = px(0),          # line above the title
    heading.border.bottom.width = px(0),     # line directly under the title
    column_labels.border.top.width = px(0)   # <-- line you still see (top of labels row)
  )


```
:::

::: {.column width="40%"}
![](media/images/w01_s21_image.jpeg){fig-alt="Single cube emphasizing an atomic unit of observation in the data." width="100%"}
:::

::: {.column width="30%"}
```{r}
numbers_df |>
  gt() |>
  tab_header(title = md("**Numbers**")) |>
  cols_label(Label = "", Value = "") |>
  tab_options(
    table.width = pct(90),
    table.border.top.width = px(0),          # line above the title
    heading.border.bottom.width = px(0),     # line directly under the title
    column_labels.border.top.width = px(0)   # <-- line you still see (top of labels row)
  )
```
:::
::::::

## [Summarized Data]{.sr-only}

:::::::: columns
:::: {.column width="30%"}
### Dimensions

::: tight-list
-   Categories
-   Filters
-   Axis Labels
:::
::::

::: {.column width="40%"}
<br> <br> <br> <br> ![](media/images/w01_s22_stack.png){fig-alt="An ordered stack of multiple atomic units making it possible to summarize the data with measures and summary statistics." width="100%"}
:::

:::: {.column width="30%"}
### Measures

::: tight-list
-   Averages
-   Standard Deviation
-   Counts
-   Sums
:::

```{r}
june_glamping <- sleep %>%
  filter(Month == "June", Location == "Camping")
# If you want only main sleeps, uncomment:
# june_glamping <- june_glamping %>% filter(SleepEventType == "Main")

mean_minutes   <- mean(june_glamping$TotalMinutes, na.rm = TRUE)
median_minutes <- median(june_glamping$TotalMinutes, na.rm = TRUE)
avg_quality    <- mean(june_glamping$SleepQuality, na.rm = TRUE)
n_records      <- nrow(june_glamping)

summary_vertical <- tibble::tibble(
  Summary = c(
    glue("Mean = {sprintf('%.2f', mean_minutes)} Minutes"),
    glue("Median = {round(median_minutes)} Minutes"),
    glue("Quality = {percent(avg_quality, accuracy = 0.01)}"),
    glue("N Records = {comma(n_records)}")
  )
)


summary_tbl <-
  summary_vertical |>
  gt() |>
  tab_header(title = md("**June Camping**")) |>
  cols_label(Summary = "") |>
  # Minimal, readable sizing for slides
  tab_options(
    table.width = pct(90),
    table.font.size = px(18),
    data_row.padding = px(4),

    # Remove lines around the title/header and table edges
    table.border.top.width = px(0),
    table.border.bottom.width = px(0),
    heading.border.bottom.width = px(0),
    column_labels.border.top.width = px(0),
    column_labels.border.bottom.width = px(0),

    # Optional: remove row separators for a ‚Äúno-chrome‚Äù card look
    table_body.hlines.width = px(0)
  )
summary_tbl

```
::::
::::::::

## Tall vs Wide

```{r}

library(readr)
library(dplyr)
library(gt)
library(scales)

# --- Load data (uncomment if needed) ---
# sleep <- read_csv("week01/data/sleep_tracking_Jan-Jun_2025_with_zip.csv",
#                   show_col_types = FALSE)

# --- Define columns ---
# Dimensions (categorical / discrete identifiers)
dims <- c(
  "Date", "DayOfWeek", "Month",
  "PersonName", "Gender",
  "Location", "SleepEventType"
)

# Measures (numeric)
meas <- c(
  "StartTime", "EndTime","TotalMinutes", "REMMinutes", "DeepMinutes",
  "LightMinutes", "SleepQuality"
)

# --- Take head(20) and select columns in desired order ---
tbl20 <- sleep %>%
  select(all_of(dims), all_of(meas)) %>%
  slice_head(n = 15)

# --- Format SleepQuality as a percentage for display ---
# (We‚Äôll use gt::fmt_percent to keep the underlying numeric values numeric.)
# If SleepQuality is not numeric, coerce it first:
# tbl20 <- tbl20 %>% mutate(SleepQuality = as.numeric(SleepQuality))

# --- Tableau-like colors (approx) ---
tableau_blue  <- "#4E79A7"  # spanner/header for dimensions (Tableau-like blue)
tableau_green <- "#59A14F"  # spanner/header for measures  (Tableau-like green)
blue_fill     <- "#EAF2FB"  # light blue fill for dimension columns
green_fill    <- "#EAF6EA"  # light green fill for measure columns
header_text   <- "white"

# --- Build gt table with styling ---
gt_tbl <- tbl20 |>
  gt() |>
  # Spanners over the dimension and measure blocks
  tab_spanner(
    label = "Dimensions",
    columns = all_of(dims)
  ) |>
  tab_spanner(
    label = "Measures",
    columns = all_of(meas)
  ) |>
  # Format SleepQuality as percent with 2 decimals (e.g., 82.35%)
  fmt_percent(
    columns = "SleepQuality", decimals = 2
  ) |>
  # Shade dimension columns (light blue)
  tab_style(
    style = cell_fill(color = blue_fill),
    locations = cells_body(columns = all_of(dims))
  ) |>
  # Shade measure columns (light green)
  tab_style(
    style = cell_fill(color = green_fill),
    locations = cells_body(columns = all_of(meas))
  ) |>
  # Color the spanner headers to match Tableau-like pills
  tab_style(
    style = list(cell_fill(color = tableau_blue), cell_text(color = header_text)),
    locations = cells_column_spanners(spanners = "Dimensions")
  ) |>
  tab_style(
    style = list(cell_fill(color = tableau_green), cell_text(color = header_text)),
    locations = cells_column_spanners(spanners = "Measures")
  ) |>
  # Optional: make it a bit tighter and readable
  tab_options(
    table.font.size = px(12),
    data_row.padding = px(6),
    column_labels.background.color = "white",
    column_labels.font.weight = "bold"
  ) |>
  cols_label(
    SleepEventType = "EventType",
    REMMinutes = "REMMinutes",
    DeepMinutes = "DeepMinutes",
    LightMinutes = "LightMinutes",
    TotalMinutes = "TotalMinutes",
    SleepQuality = "SleepQuality"
  )

gt_tbl


```

## Principles of Tidy Data

-   *Each variable you measure should be in one column*
-   *Each observation of that variable should be in a different row*
-   *There should be one table for each type of observational unit*
-   *If you have multiple tables you need a key to link them*

## [Jump to Conclusions 2]{.sr-only}

Extract

## [Jump to Conclusions 2]{.sr-only}

Extract

## [Jump to Conclusions 2]{.sr-only}

Transform

## [Jump to Conclusions 2]{.sr-only}

Load

## Tableau

![](media/images/w01_s26_image.png){fig-alt="Tableau branding indicating the visualization tool introduced in this course." width="100%"}

## Posit.cloud

![](media/images/w01_s27_image.png){fig-alt="Posit Cloud branding indicating a browser‚Äëbased RStudio environment for analysis." width="100%"}

## [Jump to Conclusions 2]{.sr-only}

Scary R

```{r echo=TRUE }
library(eco230r)
library(dplyr)

abnb |>
  idt(listed_price~instant_bookable)

```

```{r echo=TRUE }
library(eco230r)
library(dplyr)

abnb |>
  ano(listed_price~room_type)

```

## [Summary and Prime Directive]{.sr-only}

<br><br><br>

### Before running any statistics, what are the three questions you must answer about a dataset?

<br>

1.  What does one row represent?
2.  What kind of variables do I have?
3.  What question can this data answer?
