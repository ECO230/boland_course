{"title":"ECO 230 Section 012","markdown":{"yaml":{"title":"ECO 230 Section 012","author":"Mike Boland, MBA","format":{"revealjs":{"theme":["default","../shared/styles/boland-reveal.scss"],"css":"../shared/styles/accessibility.css","slide-number":true,"hash":true,"controls":true,"transition":"fade","pdf-export":true,"toc":false,"self-contained":false,"center":false,"margin":0}},"execute":{"echo":false}},"headingText":"Can you trust this conclusion?","containsRefs":false,"markdown":"\n\n```{r}\n#imports\nsource('../shared/scripts/gt_boland.R')\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(lubridate)\nlibrary(stringr)\nlibrary(glue)\nlibrary(here)\nlibrary(eco230r)\n\n```\n\n\n\n## Use Instant Booking Wisely\n\nAirbnb Owners should enable **Instant Booking** in Fall ‚Äî it's the unequivocally best season for superior ratings and returns.\n\n```{r airbnb echo:false}\n\n#install.packages(c(\"readr\",\"dplyr\",\"tidyr\",\"lubridate\",\"stringr\",\"glue\",\"here\"))  # if needed\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(lubridate)\nlibrary(stringr)\nlibrary(glue)\nlibrary(here)\nlibrary(eco230r)\n\n\n# --- Adjust the path to where your file lives ---\ndata_path <- here(\"shared\", \"data\", \"airbnb_chicago.csv\")\ndata_path_sim <- here(\"week01\",\"data\",\"airbnb_chicago_two_properties_bookings_sim.csv\"\n)\n\n# 1) Load data --------------------------------------------------------------\nabnb <- read_csv(data_path, show_col_types = FALSE)\nabnb_sim <- read_csv(data_path_sim, show_col_types = FALSE)\n\n\n# 2) Coerce instant_bookable into logical (t/f/TRUE/FALSE variants) --------\nabnb <- abnb %>%\n  mutate(instant_bookable = tolower(as.character(instant_bookable)) %in% c(\"t\",\"true\"))\n\n# 3) Parse the three date-like columns (WRONG: we will treat these as bookings)\n#    These are listing/host timeline fields, NOT actual stay dates. (That‚Äôs the point!)\nabnb <- abnb %>%\n  mutate(\n    first_review = suppressWarnings(mdy(first_review)),\n    host_since   = suppressWarnings(mdy(host_since)),\n    last_review  = suppressWarnings(mdy(last_review))\n  )\n\n# 4) Stack the three columns into one fake \"booking date\" -------------------\n#    üö© WRONG: we‚Äôre pretending each row *is a booking*, and each of these dates is a booking timestamp.\nlong_wrong <- abnb %>%\n  select(\n    id, listed_price, review_scores_rating, instant_bookable,\n    first_review, host_since, last_review\n  ) %>%\n  pivot_longer(\n    cols = c(first_review, host_since, last_review),\n    names_to   = \"which_date\",\n    values_to  = \"fake_booking_date\"\n  ) %>%\n  filter(!is.na(fake_booking_date))\n\n# 5) Derive a naive season from the calendar month -------------------------\nto_season <- function(m) {\n  if (m %in% c(12, 1, 2))  return(\"Winter\")\n  if (m %in% c(3, 4, 5))   return(\"Spring\")\n  if (m %in% c(6, 7, 8))   return(\"Summer\")\n  return(\"Fall\")\n}\n\n\nlong_wrong <- long_wrong %>%\n  mutate(\n    Season = case_when(\n      month(fake_booking_date) %in% c(12, 1, 2) ~ \"Winter\",\n      month(fake_booking_date) %in% c(3, 4, 5)  ~ \"Spring\",\n      month(fake_booking_date) %in% c(6, 7, 8)  ~ \"Summer\",\n      TRUE                                      ~ \"Fall\"\n    )\n  )\n\n\n# 6) Build the gloriously wrong seasonal summary ---------------------------\n#    - \"bookings\" = count of stacked rows\n#    - \"rating_dollars\" = rating * price  (üö© unit mashup)\nseason_summary <- long_wrong %>%\n  group_by(Season) %>%\n  summarise(\n    bookings      = n(),\n    avg_price     = mean(listed_price, na.rm = TRUE),\n    avg_rating    = mean(review_scores_rating, na.rm = TRUE),\n    instant_share = mean(instant_bookable, na.rm = TRUE)\n  ) %>%\n  ungroup() %>%\n  mutate(\n    rating_dollars = avg_rating * avg_price  # üö© nonsense cross-units\n  ) %>%\n  arrange(desc(rating_dollars))\n\n# 7) Print the confidently wrong conclusion --------------------------------\nbest_season <- season_summary %>% slice(1) %>% pull(Season)\n\n#cat(glue(\"\n#CONFIDENT (but wrong) Conclusion:\n#Enable Instant Book in {best_season} ‚Äî it's the unequivocally best season for superior ratings and returns.\\n\n#\"))\n\n\n\n\n```\n\n```{r ab_flawed}\n\nlibrary(dplyr)\nlibrary(gt)\nlibrary(scales)\n\n\n\nseason_summary %>%\n  mutate(\n    `Avg Price (USD)` = dollar(avg_price, accuracy = 0.01),\n    `Avg Rating`      = number(avg_rating, accuracy = 0.01),\n    `Instant-Book %`  = percent(instant_share, accuracy = 0.01),\n    `Rating √ó Price`  = number(rating_dollars, big.mark = \",\", accuracy = 0.01)\n  ) %>%\n  select(\n    Season,\n    `Bookings` = bookings,\n    `Avg Price (USD)`, `Avg Rating`, `Instant-Book %`, `Rating √ó Price`\n  ) %>%\n  gt() %>%\n  # Minimal typography‚Äîno header, notes, or shading\n  fmt_number(columns = \"Bookings\", decimals = 0, sep_mark = \",\") %>%\n  tab_options(\n    table.width = pct(100),\n    table.font.size = px(24),\n    data_row.padding = px(4),\n    column_labels.font.weight = \"bold\",\n    table.border.top.width = px(0),\n    table.border.bottom.width = px(0),\n    column_labels.border.top.width = px(0),\n    column_labels.border.bottom.width = px(0)\n  )\n\n\n\n```\n\n## [Sample Airbnb Data]{.sr-only}\n\n```{r ab_detail}\n\n\n# Minimalist, slide-friendly gt table for head_20_flags\nlibrary(dplyr)\nlibrary(gt)\nlibrary(stringr)\nlibrary(scales)\nlibrary(lubridate)\n\n\n# 20 rows that should raise eyebrows: these are properties/listings, not bookings.\nhead_20_flags <- abnb %>%\n  select(\n    # IDs & label-like fields that scream \"listing\"\n    id, name, property_type, room_type, neighbourhood, zipcode,\n    # Capacity-level fields (not per-stay)\n    accommodates, bedrooms, beds,\n    # The three date fields we are misusing as bookings (üö©)\n    host_since, first_review, last_review,\n    # Aggregated stats at the listing level (üö© not a single-stay field)\n    number_of_reviews, review_scores_rating,\n    # Price & toggles\n    listed_price, instant_bookable,\n    \n  ) %>%\n  slice_head(n = 20)\n\n\n# OPTIONAL: if you want to (slightly) shorten long listing names before gt\nhead_20_print <- head_20_flags %>%\n  mutate(\n    # Present booleans compactly\n    instant_bookable = ifelse(instant_bookable, \"Yes\", \"No\"),\n    # Nicely formatted numbers\n    listed_price = dollar(listed_price, accuracy = 0.01),\n    number_of_reviews = number(number_of_reviews, big.mark = \",\", accuracy = 1),\n    review_scores_rating = number(review_scores_rating, accuracy = 0.01),\n    # Format dates (use what fits your class better)\n    host_since   = format(as.Date(host_since),   \"%Y-%m-%d\"),\n    first_review = format(as.Date(first_review), \"%Y-%m-%d\"),\n    last_review  = format(as.Date(last_review),  \"%Y-%m-%d\"),\n    # Light truncation to avoid column blowout on slides\n    name           = str_trunc(name,           38),\n    property_type  = str_trunc(property_type,  18),\n    room_type      = str_trunc(room_type,      18),\n    neighbourhood  = str_trunc(neighbourhood,  18),\n    zipcode        = str_trunc(as.character(zipcode), 10)\n  )\n\n# Render with strict widths + tight spacing to fit 20 rows on a slide\ngt_tbl <- head_20_print %>%\n  select(\n    id, name, property_type, room_type, neighbourhood, zipcode,\n    accommodates, bedrooms, beds,\n    host_since, first_review, last_review,\n    number_of_reviews, review_scores_rating,\n    listed_price, instant_bookable\n  ) %>%\n  gt() %>%\n  # Column labels: short & readable (keeps header height small)\n  cols_label(\n    id = \"ID\",\n    name = \"Name\",\n    property_type = \"Property\",\n    room_type = \"Room\",\n    neighbourhood = \"Neighborhood\",\n    zipcode = \"ZIP\",\n    accommodates = \"Sleeps\",\n    bedrooms = \"BR\",\n    beds = \"Beds\",\n    host_since = \"Host Since\",\n    first_review = \"First Review\",\n    last_review = \"Last Review\",\n    number_of_reviews = \"# Reviews\",\n    review_scores_rating = \"Rating\",\n    listed_price = \"Price\",\n    instant_bookable = \"IB?\"\n  ) %>%\n  # Force compact widths: adjust as needed for your slide theme\n  cols_width(\n    id ~ px(68),\n    name ~ px(220),\n    property_type ~ px(120),\n    room_type ~ px(110),\n    neighbourhood ~ px(120),\n    zipcode ~ px(78),\n    accommodates ~ px(70),\n    bedrooms ~ px(60),\n    beds ~ px(60),\n    host_since ~ px(100),\n    first_review ~ px(100),\n    last_review ~ px(100),\n    number_of_reviews ~ px(90),\n    review_scores_rating ~ px(80),\n    listed_price ~ px(90),\n    instant_bookable ~ px(50)\n  ) %>%\n  # Minimal borders, tight padding, small font to fit 20 rows\n  tab_options(\n    table.width = pct(100),\n    table.font.size = px(10),    # try px(11) if still tight\n    data_row.padding = px(2),    # tighter rows\n    column_labels.padding = px(2),\n    table.border.top.width = px(0),\n    table.border.bottom.width = px(0),\n    column_labels.border.top.width = px(0),\n    column_labels.border.bottom.width = px(0)\n  ) %>%\n  # Prevent long strings from expanding columns further\n  opt_vertical_padding(scale = 0.75) %>%\n  opt_horizontal_padding(scale = 0.9)\n\ngt_tbl\n\n```\n\n# What is Statistics?\n\n## {background-image=\"media/images/w01_s03_image.png\" background-position=\"left center\" background-size=\"auto 150%\" background-repeat=\"no-repeat\" fig-alt=\"Photo of several dogs lying on a blanket; playful opener for the topic.\"}\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n\nWhat is **Statistics**?\n\nWhat is **Analytics**?\n\n:::\n\n::::\n\n## {background-image=\"media/images/w01_s03_image.png\" background-position=\"left center\" background-size=\"auto 150%\" background-repeat=\"no-repeat\" fig-alt=\"There are three dogs in this picture. One has black fur, one has brown, one is an idiot.\"}\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n**Analytics** is the **art** of finding out what is in your data.\n\n:::\n\n::::\n\n\n## {background-image=\"media/images/w01_s03_image.png\" background-position=\"left center\" background-size=\"auto 150%\" background-repeat=\"no-repeat\" fig-alt=\"We don't need to see every dog in the world to know that most dogs have fur, they generally have 4 paws etc...\"}\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n\nIf you can (with some effort) find the answer with certainty you are using **Analytics**.\n\n:::\n\n::::\n\n## {background-image=\"media/images/w01_s03_image.png\" background-position=\"left center\" background-size=\"auto 150%\" background-repeat=\"no-repeat\" fig-alt=\"When we need to get specific we need to go beyond analytics. E.g. how much food does the average dog eat?\"}\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n**Analytics** deals with what you know.\n\n**Statistics** deals with what you do not know.\n\n:::\n\n::::\n\n## {background-image=\"media/images/w01_s03_image.png\" background-position=\"left center\" background-size=\"auto 150%\" background-repeat=\"no-repeat\" fig-alt=\"Analytics helps us frame what questions we need clarity on and which questions we need the discipline of statistics to answer.\"}\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n**Analytics** turns curiosity into questions.\n\n**Statistics** turns data into answers.\n\n:::\n\n::::\n\n## {background-image=\"media/images/w01_s03_image.png\" background-position=\"left center\" background-size=\"auto 150%\" background-repeat=\"no-repeat\" fig-alt=\"This picture, a spreadsheet a database, sensor information it is all data in which we can perform analytics and statistics.\"}\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n**Analytics** is the **art** of finding out what is in your data.\n\n**Statistics** is the **science** of making decisions under uncertainty.\n\n:::\n\n::::\n\n::: notes\n-   Open with intuition: students already *do* analytics informally.\n-   Emphasize uncertainty as the key dividing line.\n-   Pause after the third fragment and ask for examples.\n:::\n\n# What does one row represent?\n\n## [Jump to Conclusions 2]{.sr-only}\n\n### Calculate the Total Yearly Revenue for Each Property\n\n```{r ab_grain}\n\n\n# --- Packages ---\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(lubridate)\nlibrary(gt)\nlibrary(stringr)\nlibrary(scales)\n\nset.seed(20260126)  # reproducible sampling for the slide\n\n# Helper: truncation for long text so columns stay narrow on slide\n.trunc <- function(x, width) ifelse(is.na(x), x, str_trunc(x, width = width, side = \"right\", ellipsis = \"‚Ä¶\"))\n\n# -----------------------------------------------------------------------------------\n# 1) Identify properties to show\n#    - Use properties that actually have simulated bookings in `abnb_sim`\n#    - Keep exactly TWO for the booking table, and ensure they also appear in listing table\n# -----------------------------------------------------------------------------------\nsim_ids <- abnb_sim %>%\n  distinct(property_id) %>%\n  pull(property_id) %>%\n  sort()\n\n# Use the first two (or pin explicit IDs if you prefer)\nshow_ids <- head(sim_ids, 2)\n# show_ids <- c(12854553, 743217)  # <- example: pin explicit property IDs\n\n# -----------------------------------------------------------------------------------\n# 2) LISTING-LEVEL TABLE (abnb): 10 total properties including the two with bookings\n# -----------------------------------------------------------------------------------\n# Sample additional properties to reach 10 total (but keep show_ids)\nnum_needed <- max(0, 6 - length(show_ids))\nextra_ids <- abnb %>%\n  filter(!id %in% show_ids) %>%\n  distinct(id) %>%\n  slice_sample(n = num_needed) %>%\n  pull(id)\n\nids_for_abnb_table <- c(show_ids, extra_ids)\n\n# Select columns (include overlap + a few property-only attributes)\nabnb_tbl_data <- abnb %>%\n  filter(id %in% ids_for_abnb_table) %>%\n  select(\n    id, name, room_type, listed_price, accommodates, neighbourhood,\n    bedrooms, bathrooms, beds, cancellation_policy\n  ) %>%\n  arrange(name)\n\n# Render listing-level GT table (compact VT styling, KaTeX-safe headers)\ntbl_abnb_vt <-\n  abnb_tbl_data %>%\n  gt() %>%\n  cols_label(\n    id = \"ID\",\n    name = \"Name\",\n    room_type = \"Room\",\n    listed_price = \"List\",\n    accommodates = \"Sleeps\",\n    neighbourhood = \"N‚Äôhood\",\n    bedrooms = \"BR\",\n    bathrooms = \"BA\",\n    beds = \"Beds\",\n    cancellation_policy = \"Cancel\"\n  ) %>%\n  # Truncate long strings so fixed widths don't wrap\n  text_transform(\n    locations = cells_body(columns = c(name, neighbourhood, room_type, cancellation_policy)),\n    fn = function(x) .trunc(x, width = 28)\n  ) %>%\n  # Currency in cells is fine; KaTeX only cares about headers\n  fmt_currency(columns = listed_price, currency = \"USD\", decimals = 0) %>%\n  # Narrow, predictable column widths for slides\n  cols_width(\n    id ~ px(70),\n    name ~ px(230),\n    room_type ~ px(110),\n    listed_price ~ px(80),\n    accommodates ~ px(75),\n    neighbourhood ~ px(130),\n    bedrooms ~ px(55),\n    bathrooms ~ px(55),\n    beds ~ px(55),\n    cancellation_policy ~ px(110)\n  ) %>%\n  # Minimal borders / tight padding / small font ‚Äî your VT style\n  tab_options(\n    table.width = pct(100),\n    table.font.size = px(9),\n    data_row.padding = px(1),\n    column_labels.padding = px(1),\n    table.border.top.width = px(0),\n    table.border.bottom.width = px(0),\n    column_labels.border.top.width = px(0),\n    column_labels.border.bottom.width = px(0)\n  ) %>%\n  opt_vertical_padding(scale = 0.6) %>%\n  opt_horizontal_padding(scale = 0.8) %>%\n  tab_caption(md(\"**Dataset A** ‚Äî Airbnb Rental Data\"))\n\n# -----------------------------------------------------------------------------------\n# 3) BOOKING-LEVEL TABLE (abnb_sim): 5 random rows per property (for the two selected)\n# -----------------------------------------------------------------------------------\nabnb_sim_tbl_data <- abnb_sim %>%\n  filter(property_id %in% show_ids) %>%\n  transmute(\n    id = property_id,\n    name,\n    room_type,\n    accommodates,\n    neighbourhood,\n    checkin_date = as_date(checkin_date),\n    nights,\n    guest_count,\n    status,\n    price_per_night,\n    total_price = tidyr::replace_na(total_price, 0)\n  ) %>%\n  arrange(name, checkin_date) %>%\n  group_by(id) %>%\n  # Sample exactly 5 random bookings per property (or all if <5)\n  filter(row_number() %in% sample.int(n(), size = min(3, n()), replace = FALSE)) %>%\n  ungroup() %>%\n  arrange(name, checkin_date)\n\n# Render booking-level GT table (compact VT styling, KaTeX-safe headers)\ntbl_abnb_sim_vt <-\n  abnb_sim_tbl_data %>%\n  gt() %>%\n  cols_label(\n    id = \"ID\",\n    name = \"Name\",\n    room_type = \"Room\",\n    accommodates = \"Sleeps\",\n    neighbourhood = \"N‚Äôhood\",\n    checkin_date = \"Check‚Äëin\",\n    nights = \"Nts\",\n    guest_count = \"Guests\",\n    status = \"Status\",\n    price_per_night = \"Price/Nt\",  # no $ in header ‚Üí avoids KaTeX\n    total_price = \"Total\"           # no $ in header ‚Üí avoids KaTeX\n  ) %>%\n  # Truncate long strings to stay within widths\n  text_transform(\n    locations = cells_body(columns = c(name, neighbourhood, room_type, status)),\n    fn = function(x) .trunc(x, width = 24)\n  ) %>%\n  fmt_currency(columns = c(price_per_night, total_price), currency = \"USD\", decimals = 0) %>%\n  cols_width(\n    id ~ px(70),\n    name ~ px(220),\n    room_type ~ px(100),\n    accommodates ~ px(75),\n    neighbourhood ~ px(120),\n    checkin_date ~ px(90),\n    nights ~ px(45),\n    guest_count ~ px(60),\n    status ~ px(90),\n    price_per_night ~ px(90),\n    total_price ~ px(100)\n  ) %>%\n  tab_options(\n    table.width = pct(100),\n    table.font.size = px(9),\n    data_row.padding = px(1),\n    column_labels.padding = px(1),\n    table.border.top.width = px(0),\n    table.border.bottom.width = px(0),\n    column_labels.border.top.width = px(0),\n    column_labels.border.bottom.width = px(0)\n  ) %>%\n  opt_vertical_padding(scale = 0.6) %>%\n  opt_horizontal_padding(scale = 0.8) %>%\n  tab_caption(md(\"**Dataset B** ‚Äî Airbnb Rental Data\"))\n\n\n\n```\n\n```{r ab_property}\ntbl_abnb_vt\n```\n\n```{r ab_bookings}\ntbl_abnb_sim_vt\n```\n\n\n\n## [Rows vs Columns]{.sr-only}\n\n::::: columns\n::: {.column width=\"50%\"}\n### Columns\n\n![](media/images/w01_s19_image.png){fig-alt=\"Icon emphasizing the concept of columns‚Äîvariables‚Äîin a dataset.\" width=\"100%\"}\n:::\n\n::: {.column width=\"50%\"}\n<br><br><br><br><br>\n\n### Rows\n\n![](media/images/w01_s19_image.jpg){fig-alt=\"Icon emphasizing the concept of rows‚Äîobservations‚Äîin a dataset.\" width=\"100%\"}\n:::\n:::::\n\n## Unit of Analysis\n\n::::::: columns\n::: column-page\n**What does each *thingie* (row, observation, grain) of this data represent?**\n:::\n\n:::: {.column width=\"58%\"}\n::: tight-list\n-   Everyone in a *zipcode*\n-   Individual consumers\n-   Individual purchases\n-   GDP of an economy\n-   Population of a planet\n:::\n::::\n\n::: {.column width=\"42%\"}\n![](media/images/w01_s14_image.png){fig-alt=\"Photo of several dogs lying on a blanket; playful opener for the topic.\" height=\"65%\"}\n:::\n:::::::\n\n## Data Grouping: Cross-Sectional {background-image=\"media/images/w01_s15_image.jpeg\" background-size=\"cover\" background-opacity=\"0.95\" fig-alt=\"Freeze‚Äëframe droplet illustrating a cross‚Äësectional snapshot at a single point in time.\"}\n\n## Data Grouping: Time-Series\n\n![](media/images/w01_s16_image.jpeg){fig-alt=\"Growth sequence image suggesting change over time in a time‚Äëseries.\" height=\"85%\"}\n\n## Data Grouping: Panel\n\n![](media/images/w01_s17_image.jpeg){.r-stretch fig-alt=\"Grid‚Äëstyle visual suggesting repeated measures on multiple units across time (panel data).\" fig-align=\"right\"}\n\n# What kind of variables do I have?\n\n## [Tall vs Wide Data]{.sr-only}\n\n### Summarize total minutes of sleep by month and location\n```{r sleep_data echo:FALSE}\nlibrary(readr)\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(stringr)\nlibrary(gt)\nlibrary(here)\n\n# ---- 1) Load with explicit column types ----\n# Adjust the path as needed (from your project root):\ncsv_path <- here(\"week01\", \"data\", \"sleep_tracking_Jan-Jun_2025_with_zip.csv\")\ncsv_path_zips <- here(\"week01\", \"data\", \"simulated_zip_profiles.csv\")\n\n# 1) Load data --------------------------------------------------------------\n\nsleep_zips <- read_csv(csv_path_zips)\n\nsleep <- read_csv(\n  file = csv_path,\n  col_types = cols(\n    Date          = col_character(),   # force character so we control parsing\n    DayOfWeek     = col_character(),\n    Month         = col_character(),\n    PersonName    = col_character(),\n    Gender        = col_character(),\n    Location      = col_character(),\n    SleepEventType= col_character(),\n    StartTime     = col_character(),   # force character\n    EndTime       = col_character(),   # force character\n    TotalMinutes  = col_integer(),\n    REMMinutes    = col_integer(),\n    DeepMinutes   = col_integer(),\n    LightMinutes  = col_integer(),\n    SleepQuality  = col_double(),\n    ZipCode       = col_character()\n  ),\n  show_col_types = FALSE\n)\n\n# ---- 2) Fix Date if it came in as an Excel serial ----\n# If Date looks like a 5-digit integer (e.g., \"45295\"), convert from Excel origin.\nis_excel_serial <- function(x_chr) {\n  all(str_detect(x_chr, \"^\\\\d{4,5}$\"), na.rm = TRUE)\n}\n\nif (is_excel_serial(sleep$Date)) {\n  # Excel's typical origin is 1899-12-30 for most exports\n  sleep$Date <- as.Date(as.numeric(sleep$Date), origin = \"1899-12-30\")\n} else {\n  # Otherwise, parse as ISO or m/d/Y\n  # Try YYYY-MM-DD first, then m/d/Y fallback\n  parsed1 <- suppressWarnings(ymd(sleep$Date, quiet = TRUE))\n  parsed2 <- ifelse(is.na(parsed1),\n                    suppressWarnings(mdy(sleep$Date, quiet = TRUE)),\n                    parsed1)\n  sleep$Date <- as.Date(parsed2)\n}\n\n# ---- 3) Robust parsers for StartTime/EndTime ----\n# These can be \"2025-01-03 22:10\", or \"9/7/2023 10:53 PM\", etc.\nparse_start_end <- function(x_chr) {\n  x_chr <- str_trim(x_chr)\n  # Try multiple common orders:\n  # - \"YYYY-MM-DD HH:MM\"\n  # - \"m/d/Y H:M p\"\n  # - \"Y-m-d H:M:S\" (if seconds exist)\n  # - \"m/d/Y I:M:S p\" etc.\n  parse_date_time(\n    x_chr,\n    orders = c(\n      \"Y-m-d H:M\",\n      \"Y-m-d H:M:S\",\n      \"m/d/Y I:M p\",\n      \"m/d/Y I:M:S p\",\n      \"m/d/y I:M p\",\n      \"m/d/y I:M:S p\"\n    ),\n    tz = \"UTC\"   # keep neutral; display only time-of-day\n  )\n}\n\nsleep$StartTime_dt <- parse_start_end(sleep$StartTime)\nsleep$EndTime_dt   <- parse_start_end(sleep$EndTime)\n\n# If you KNOW StartTime/EndTime are already ISO strings (e.g., \"2025-01-03 22:10\"),\n# you could also use:\n# sleep$StartTime_dt <- ymd_hm(sleep$StartTime, quiet = TRUE)\n# sleep$EndTime_dt   <- ymd_hm(sleep$EndTime, quiet = TRUE)\n\n# ---- 4) Formatters ----\nfmt_time_12h <- function(dt) {\n  # Handle NA gracefully:\n  ifelse(\n    is.na(dt), \n    NA_character_,\n    str_to_upper(format(dt, \"%I:%M %p\")) |>\n      str_replace(\"^0\", \"\") |>\n      str_replace_all(\"AM\", \"A.M.\") |>\n      str_replace_all(\"PM\", \"P.M.\")\n  )\n}\n\nfmt_pct <- function(x) paste0(round(100 * x), \"%\")\n```\n\n```{r sleep_filter echo:FALSE}\n\n\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(readr)\n\nweek_data <- sleep %>%\n  filter(\n    Date >= \"2025-01-05\",\n    Date <= \"2025-01-11\",\n    PersonName %in% c(\"Mike\", \"Cam\"),\n    SleepEventType == \"Main\"\n  ) %>%\n  select(\n    Name        = PersonName,\n    Gender,\n    Location,\n    Date,\n    DayOfWeek,\n    TotalMinutes\n  ) %>%\n  # safety: in case of multiple entries per person/day\n  group_by(Name, Gender, Location, Date, DayOfWeek) %>%\n  summarise(TotalMinutes = sum(TotalMinutes), .groups = \"drop\")\n\n\n```\n\n::::::: columns\n\n:::: {.column width=\"30%\"}\n\n```{r sleep_tall}\n\n\n\ntall_week <- sleep %>%\n  filter(\n    Date >= \"2025-01-05\",\n    Date <= \"2025-01-11\",\n    PersonName %in% c(\"Mike\", \"Cam\"),\n    SleepEventType == \"Main\"\n  ) %>%\n  select(\n    Name        = PersonName,\n    Gender,\n    Location,\n    Date,\n    DayOfWeek,\n    TotalMinutes\n  ) %>%\n  # guard against multiple rows per person/day\n  group_by(Name, Gender, Location, Date, DayOfWeek) %>%\n  summarise(TotalMinutes = sum(TotalMinutes), .groups = \"drop\") %>%\n  # üîë CRITICAL FIX: coerce BEFORE pivot_longer\n  mutate(across(-Name, as.character)) %>%\n  # now pivot safely\n  pivot_longer(\n    cols = -Name,\n    names_to = \"Variable\",\n    values_to = \"Value\"\n  ) %>%\n  arrange(Name, Variable)\n\n\ntall_gt <- tall_week %>%\n  gt(rowname_col = \"Name\") %>%\n  tab_header(\n    title = md(\"**Tall ‚Äî More rows, fewer columns**\")\n  ) %>%\n  cols_label(\n    Variable = \"Variable\",\n    Value    = \"Value\"\n  ) %>%\n  fmt_missing(everything(), missing_text = \"\") %>%\n  tab_options(\n    container.height = px(420),\n    container.overflow.y = TRUE,\n    table.font.size = px(12),\n    data_row.padding = px(4),\n\n    # Remove lines around the title/header and table edges\n    table.border.top.width = px(0),\n    table.border.bottom.width = px(0),\n    heading.border.bottom.width = px(0),\n    column_labels.border.top.width = px(0),\n    column_labels.border.bottom.width = px(0),\n\n    # Optional: remove row separators for a ‚Äúno-chrome‚Äù card look\n    table_body.hlines.width = px(0)\n  )\n\ntall_gt\n\n```\n\n::::\n\n:::: {.column width=\"70%\"}\n\n```{r sleep_wide}\n\nwide_week <- week_data %>%\n  select(Name, Gender, Location, Date, TotalMinutes) %>%\n  pivot_wider(\n    names_from  = Date,\n    values_from = TotalMinutes\n  ) %>%\n  arrange(Name)\n\n\n\nwide_gt <- wide_week %>%\n  gt() %>%\n  tab_header(\n    title = md(\"**Wide ‚Äî More columns, fewer rows**\")\n  ) %>%\n  fmt_missing(everything(), missing_text = \"\") %>%\n  tab_options(\n    container.overflow.x = TRUE,\n    table.width = pct(120),\n    table.font.size = px(12),\n    data_row.padding = px(4),\n\n    # Remove lines around the title/header and table edges\n    table.border.top.width = px(0),\n    table.border.bottom.width = px(0),\n    heading.border.bottom.width = px(0),\n    column_labels.border.top.width = px(0),\n    column_labels.border.bottom.width = px(0),\n\n    # Optional: remove row separators for a ‚Äúno-chrome‚Äù card look\n    table_body.hlines.width = px(0)\n  )\n\nwide_gt\n\n```\n::::\n\n:::::::\n\n\n## Data Types\n\n<br>\n\n### Categories\nTrue/False ‚Üí `logical`  \nCategorical ‚Üí `factor`  \nOrdinal ‚Üí `factor`\n\n<br>\n\n### Numbers\nDiscrete ‚Üí `integer`  \nContinuous ‚Üí `double`\n\n\n\n---\n## Measurement Scales\n\n![](../shared/images/NOIR.svg){width=100% height=700px fig-alt=\"Visual representing Measurement scales Nominal,Ordinal,Interval, Ratio and their common uses. Nominal is more discrete Ratio is more continuous. Nominal is more appropriate for grouping Ratio is more appropriate for Summary statistics like averages and standard deviation. These uses are all on a continuum as the same variable may be used for different purposes.\"}\n\n\n## Observations - Atomic Data\n\n```{r name:sleep_desc echo:False}\n\n\n# ---- 5) Function to build the two tables for a chosen person & date ----\nmake_sleep_tables <- function(data, person = \"Mike\", date_input = \"2025-01-03\") {\n  # Accept either character date or Date class\n  date_val <- if (inherits(date_input, \"Date\")) date_input else as.Date(date_input)\n  \n  row <- data %>%\n    filter(\n      PersonName == person,\n      Date == date_val,\n      SleepEventType == \"Main\"\n    ) %>%\n    arrange(StartTime_dt) %>%\n    slice(1)\n  \n  if (nrow(row) == 0) {\n    stop(\"No 'Main' sleep row found for that person/date.\")\n  }\n  \n  categories_df <- tibble::tibble(\n    Label = c(\"Name\", \"Date\", \"Gender\", \"Location\", \"ZipCode\"),\n    Value = c(\n      row$PersonName,\n      format(row$Date, \"%m/%d/%Y\"),\n      row$Gender,\n      row$Location,\n      row$ZipCode\n    )\n  )\n  \n  numbers_df <- tibble::tibble(\n    Label = c(\n      \"Start Time\",\n      \"End Time\",\n      \"R.E.M.\",\n      \"Deep Sleep\",\n      \"Light Sleep\",\n      \"Total Sleep\",\n      \"Quality\"\n    ),\n    Value = c(\n      fmt_time_12h(row$StartTime_dt),\n      fmt_time_12h(row$EndTime_dt),\n      paste0(row$REMMinutes, \" Minutes\"),\n      paste0(row$DeepMinutes, \" Minutes\"),\n      paste0(row$LightMinutes, \" Minutes\"),\n      as.character(row$TotalMinutes),\n      fmt_pct(row$SleepQuality)\n    )\n  )\n  \n  list(categories = categories_df, numbers = numbers_df)\n}\n\n# ---- 6) Example: reproduce your case (adjust date/person to a known row) ----\ntables <- make_sleep_tables(sleep, person = \"Mike\", date_input = \"2025-01-03\")\ncategories_df <- tables$categories\nnumbers_df    <- tables$numbers\n```\n\n:::::: columns\n::: {.column width=\"30%\"}\n```{r sleep_categories }\n\n\ncategories_df |>\n  gt() |>\n  tab_header(title = md(\"**Categories**\")) |>\n  cols_label(Label = \"\", Value = \"\") |>\n  tab_options(\n    table.width = pct(90),\n    table.border.top.width = px(0),          # line above the title\n    heading.border.bottom.width = px(0),     # line directly under the title\n    column_labels.border.top.width = px(0)   # <-- line you still see (top of labels row)\n  )\n\n\n```\n:::\n\n::: {.column width=\"40%\"}\n![](media/images/w01_s21_image.jpeg){fig-alt=\"Single cube emphasizing an atomic unit of observation in the data.\" width=\"100%\"}\n:::\n\n::: {.column width=\"30%\"}\n```{r sleep_numbers}\nnumbers_df |>\n  gt() |>\n  tab_header(title = md(\"**Numbers**\")) |>\n  cols_label(Label = \"\", Value = \"\") |>\n  tab_options(\n    table.width = pct(90),\n    table.border.top.width = px(0),          # line above the title\n    heading.border.bottom.width = px(0),     # line directly under the title\n    column_labels.border.top.width = px(0)   # <-- line you still see (top of labels row)\n  )\n```\n:::\n::::::\n\n## [Summarized Data]{.sr-only}\n\n:::::::: columns\n:::: {.column width=\"30%\"}\n### Dimensions\n\n::: tight-list\n-   Categories\n-   Filters\n-   Axis Labels\n:::\n::::\n\n::: {.column width=\"40%\"}\n<br> <br> <br> <br> ![](media/images/w01_s22_stack.png){fig-alt=\"An ordered stack of multiple atomic units making it possible to summarize the data with measures and summary statistics.\" width=\"100%\"}\n:::\n\n:::: {.column width=\"30%\"}\n### Measures\n\n::: tight-list\n-   Averages\n-   Standard Deviation\n-   Counts\n-   Sums\n:::\n\n```{r sleep_summary}\njune_glamping <- sleep %>%\n  filter(Month == \"June\", Location == \"Camping\")\n# If you want only main sleeps, uncomment:\n# june_glamping <- june_glamping %>% filter(SleepEventType == \"Main\")\n\nmean_minutes   <- mean(june_glamping$TotalMinutes, na.rm = TRUE)\nmedian_minutes <- median(june_glamping$TotalMinutes, na.rm = TRUE)\navg_quality    <- mean(june_glamping$SleepQuality, na.rm = TRUE)\nn_records      <- nrow(june_glamping)\n\nsummary_vertical <- tibble::tibble(\n  Summary = c(\n    glue(\"Mean = {sprintf('%.2f', mean_minutes)} Minutes\"),\n    glue(\"Median = {round(median_minutes)} Minutes\"),\n    glue(\"Quality = {percent(avg_quality, accuracy = 0.01)}\"),\n    glue(\"N Records = {comma(n_records)}\")\n  )\n)\n\n\nsummary_tbl <-\n  summary_vertical |>\n  gt() |>\n  tab_header(title = md(\"**June Camping**\")) |>\n  cols_label(Summary = \"\") |>\n  # Minimal, readable sizing for slides\n  tab_options(\n    table.width = pct(90),\n    table.font.size = px(18),\n    data_row.padding = px(4),\n\n    # Remove lines around the title/header and table edges\n    table.border.top.width = px(0),\n    table.border.bottom.width = px(0),\n    heading.border.bottom.width = px(0),\n    column_labels.border.top.width = px(0),\n    column_labels.border.bottom.width = px(0),\n\n    # Optional: remove row separators for a ‚Äúno-chrome‚Äù card look\n    table_body.hlines.width = px(0)\n  )\nsummary_tbl\n\n```\n::::\n::::::::\n\n## Tall vs Wide\n\n```{r sleep_dims_cats}\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(gt)\nlibrary(scales)\n\n# --- Load data (uncomment if needed) ---\n# sleep <- read_csv(\"week01/data/sleep_tracking_Jan-Jun_2025_with_zip.csv\",\n#                   show_col_types = FALSE)\n\n# --- Define columns ---\n# Dimensions (categorical / discrete identifiers)\ndims <- c(\n  \"Date\", \"DayOfWeek\", \"Month\",\n  \"PersonName\", \"Gender\",\n  \"Location\", \"SleepEventType\"\n)\n\n# Measures (numeric)\nmeas <- c(\n  \"StartTime\", \"EndTime\",\"TotalMinutes\", \"REMMinutes\", \"DeepMinutes\",\n  \"LightMinutes\", \"SleepQuality\"\n)\n\n# --- Take head(20) and select columns in desired order ---\ntbl20 <- sleep %>%\n  select(all_of(dims), all_of(meas)) %>%\n  slice_head(n = 15)\n\n# --- Format SleepQuality as a percentage for display ---\n# (We‚Äôll use gt::fmt_percent to keep the underlying numeric values numeric.)\n# If SleepQuality is not numeric, coerce it first:\n# tbl20 <- tbl20 %>% mutate(SleepQuality = as.numeric(SleepQuality))\n\n# --- Tableau-like colors (approx) ---\ntableau_blue  <- \"#4E79A7\"  # spanner/header for dimensions (Tableau-like blue)\ntableau_green <- \"#59A14F\"  # spanner/header for measures  (Tableau-like green)\nblue_fill     <- \"#EAF2FB\"  # light blue fill for dimension columns\ngreen_fill    <- \"#EAF6EA\"  # light green fill for measure columns\nheader_text   <- \"white\"\n\n# --- Build gt table with styling ---\ngt_tbl <- tbl20 |>\n  gt() |>\n  # Spanners over the dimension and measure blocks\n  tab_spanner(\n    label = \"Dimensions\",\n    columns = all_of(dims)\n  ) |>\n  tab_spanner(\n    label = \"Measures\",\n    columns = all_of(meas)\n  ) |>\n  # Format SleepQuality as percent with 2 decimals (e.g., 82.35%)\n  fmt_percent(\n    columns = \"SleepQuality\", decimals = 2\n  ) |>\n  # Shade dimension columns (light blue)\n  tab_style(\n    style = cell_fill(color = blue_fill),\n    locations = cells_body(columns = all_of(dims))\n  ) |>\n  # Shade measure columns (light green)\n  tab_style(\n    style = cell_fill(color = green_fill),\n    locations = cells_body(columns = all_of(meas))\n  ) |>\n  # Color the spanner headers to match Tableau-like pills\n  tab_style(\n    style = list(cell_fill(color = tableau_blue), cell_text(color = header_text)),\n    locations = cells_column_spanners(spanners = \"Dimensions\")\n  ) |>\n  tab_style(\n    style = list(cell_fill(color = tableau_green), cell_text(color = header_text)),\n    locations = cells_column_spanners(spanners = \"Measures\")\n  ) |>\n  # Optional: make it a bit tighter and readable\n  tab_options(\n    table.font.size = px(12),\n    data_row.padding = px(6),\n    column_labels.background.color = \"white\",\n    column_labels.font.weight = \"bold\"\n  ) |>\n  cols_label(\n    SleepEventType = \"EventType\",\n    REMMinutes = \"REMMinutes\",\n    DeepMinutes = \"DeepMinutes\",\n    LightMinutes = \"LightMinutes\",\n    TotalMinutes = \"TotalMinutes\",\n    SleepQuality = \"SleepQuality\"\n  )\n\ngt_tbl\n\n\n```\n\n## Principles of Tidy Data\n\n-   *Each variable you measure should be in one column*\n-   *Each observation of that variable should be in a different row*\n-   *There should be one table for each type of observational unit*\n-   *If you have multiple tables you need a key to link them*\n\n```{r tidy_tables}\n\n\n# Packages\nlibrary(dplyr)\nlibrary(gt)\n\n# ---------- TABLE A: sleep (first 10 rows with selected columns) ----------\nsleep_tbl_data <- sleep %>%\n  select(PersonName, Gender, Location, ZipCode, TotalMinutes, SleepQuality) %>%\n  head(10)\n\ntbl_sleep_vt <-\n  sleep_tbl_data %>%\n  gt() %>%\n  cols_label(\n    PersonName   = \"Name\",\n    Gender       = \"Gender\",\n    Location     = \"Location\",\n    ZipCode      = \"ZIP\",\n    TotalMinutes = \"Minutes\",\n    SleepQuality = \"Quality\"\n  ) %>%\n  cols_width(\n    PersonName   ~ px(180),\n    Gender       ~ px(90),\n    Location     ~ px(130),\n    ZipCode      ~ px(90),\n    TotalMinutes ~ px(90),\n    SleepQuality ~ px(90)\n  ) %>%\n  tab_options(\n    table.width = pct(100),\n    table.font.size = px(10),\n    data_row.padding = px(2),\n    column_labels.padding = px(2),\n    table.border.top.width = px(0),\n    table.border.bottom.width = px(0),\n    column_labels.border.top.width = px(0),\n    column_labels.border.bottom.width = px(0)\n  ) %>%\n  opt_vertical_padding(scale = 0.75) %>%\n  opt_horizontal_padding(scale = 0.9) %>%\n  tab_caption(md(\"**Sleep (first 10):** `PersonName, Gender, Location, ZipCode, TotalMinutes, SleepQuality`\"))\n\n# ---------- TABLE B: sleep_zips (first 10 rows) ----------\nsleep_zips_tbl_data <- sleep_zips %>% head(10)\n\ntbl_sleep_zips_vt <-\n  sleep_zips_tbl_data %>%\n  gt() %>%\n  cols_label(\n    zip                     = \"ZIP\",\n    city                    = \"City\",\n    state                   = \"State\",\n    population              = \"Population\",\n    crime_rate_per_100k     = \"Crime per 100k\",\n    avg_sunny_days_per_year = \"Sunny Days\"\n  ) %>%\n  fmt_number(columns = population,              decimals = 0, sep_mark = \",\") %>%\n  fmt_number(columns = crime_rate_per_100k,     decimals = 0, sep_mark = \",\") %>%\n  fmt_number(columns = avg_sunny_days_per_year, decimals = 0) %>%\n  cols_width(\n    zip                     ~ px(90),\n    city                    ~ px(150),\n    state                   ~ px(70),\n    population              ~ px(110),\n    crime_rate_per_100k     ~ px(120),\n    avg_sunny_days_per_year ~ px(100)\n  ) %>%\n  tab_options(\n    table.width = pct(100),\n    table.font.size = px(10),\n    data_row.padding = px(2),\n    column_labels.padding = px(2),\n    table.border.top.width = px(0),\n    table.border.bottom.width = px(0),\n    column_labels.border.top.width = px(0),\n    column_labels.border.bottom.width = px(0)\n  ) %>%\n  opt_vertical_padding(scale = 0.75) %>%\n  opt_horizontal_padding(scale = 0.9) %>%\n  tab_caption(md(\"**Sleep ZIP Profiles (first 10):** `zip, city, state, population, crime_rate_per_100k, avg_sunny_days_per_year`\"))\n\n```\n\n## Tidy Data - Principles 1-3\n\n```{r tidy_base}\n# ---- Display both tables on the slide ----\ntbl_sleep_vt\n```\n\n## Tidy Data - Principle 4\n\n```{r tidy_join}\ntbl_sleep_zips_vt\n```\n\n\n# ETL\n\n## [ETL Process - Extract]{.sr-only}\n\n::: {.text-center}\n\n**Extract** | Transform | Load\n\n:::\n\n::::: columns\n\n::: {.column width=\"33%\"}\nStructured Data\n\n![](media/images/w01_s11_database.png){fig-alt=\"Icon illustrating extracting from a ordered database the ETL workflow.\" width=\"80%\"}\n\n:::\n\n::: {.column width=\"34%\"}\nThird Party\n\n![](media/images/w01_s11_census.png){fig-alt=\"Icon illustrating extracting from a third party source of structured data in the ETL workflow.\" width=\"80%\"}\n:::\n\n::: {.column width=\"33%\"}\nUnstructured Data\n\n![](media/images/w01_s11_image.png){fig-alt=\"Terminal or connector graphic showing extracted data may be unstructured or streaming ETL operations.\" width=\"80%\"}\n:::\n\n:::::\n\n\n## [ETL Process - Transform]{.sr-only}\n\n::: {.text-center}\n\nExtract | **Transform** | Load\n\n::::: columns\n\n::: {.column width=\"25%\"}\n\n![](../shared/images/logo_Excel.png){width=100px fig-alt=\"Microsoft Excel Logo\"}\n\n![](media/images/w01_s11_census.png){width=100px fig-alt=\"Icon illustrating extracting from a third party source of structured data in the ETL workflow.\"}\n\n![](../shared/images/logo_R.png){width=100px fig-alt=\"R Language Logo\"}\n\n![](../shared/images/logo_Database.png){width=100px fig-alt=\"Generic Database Logo\"}\n\n![](media/images/w01_s11_image.png){width=100px fig-alt=\"Terminal or connector graphic showing extracted data may be unstructured or streaming ETL operations.\"}\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](media/images/w01_s20_grinder.png){width=\"100%\" fig-alt=\"Microsoft Excel Logo\"}\n\n:::\n\n::: {.column width=\"25%\"}\n\n\n:::\n\n:::::\n\n:::\n\n## [ETL Process - Transform Example]{.sr-only}\n\n::: {.text-center}\n\nExtract | **Transform** | Load\n\n:::\n\n\n```{r}\n\n# ---- Packages ----\nlibrary(readr)\nlibrary(dplyr)\nlibrary(gt)\nlibrary(stringr)\n\n# ---- 0) Where the file lives ----\n# If you've downloaded via the link, keep the path as-is.\n# Otherwise, set `path` to wherever you've stored the CSV.\npath <- here(\"week01\", \"data\", \"messy_zip_54601.csv\")\n\n\n# ---- 1) Load the messy data (20 rows) ----\nmessy_zip <- read_csv(path, show_col_types = FALSE)\n\n# (Optional) confirm row/col counts in your console:\n# dim(messy_zip)\n# names(messy_zip)\n\n# ---- 2) Small helper: VT styling used across your slides ----\nvt_style_gt <- function(g) {\n  g %>%\n    tab_options(\n      table.width = pct(100),\n      table.font.size = px(10),\n      data_row.padding = px(2),\n      column_labels.padding = px(2),\n      table.border.top.width = px(0),\n      table.border.bottom.width = px(0),\n      column_labels.border.top.width = px(0),\n      column_labels.border.bottom.width = px(0)\n    ) %>%\n    opt_vertical_padding(scale = 0.75) %>%\n    opt_horizontal_padding(scale = 0.9)\n}\n\n# ---- 3) Truncate the very long column so the table fits on a slide ----\n# (Adjust `TRUNC_WIDTH` if you want more/less)\nTRUNC_WIDTH <- 60\nmessy_zip_trunc <- messy_zip %>%\n  mutate(\n    everything_raw = ifelse(\n      is.na(everything_raw),\n      everything_raw,\n      str_trunc(everything_raw, width = TRUNC_WIDTH, side = \"right\", ellipsis = \"‚Ä¶\")\n    )\n  )\n\n# ---- 4) Render ALL 20 rows with VT styling ----\ntbl_messy_zip_vt <-\n  messy_zip_trunc %>%\n  select(zip_value,state_value,county_value,population_value,fips_county,everything_raw) %>%\n  gt() %>%\n  # Keep original column names so the \"messiness\" is apparent\n  # Give a little extra room to long text columns; others will auto-size.\n  cols_width(\n    zip_value        ~ px(110),\n    state_value      ~ px(110),\n    county_value     ~ px(140),\n    population_value ~ px(130),\n    fips_county      ~ px(95),\n    everything_raw   ~ px(380)\n  ) %>%\n  vt_style_gt() %>%\n  tab_caption(md(\"**Messy ZIP 54601**\"))\n\n# ---- 5) Print the table (all 20 rows) ----\ntbl_messy_zip_vt\n\n```\n\n\n## [ETL Process - Load]{.sr-only}\n\n::: {.text-center}\n\nExtract | Transform | **Load**\n\n::::: columns\n\n::: {.column width=\"25%\"}\n\n![](../shared/images/logo_Excel.png){width=100px fig-alt=\"Microsoft Excel Logo\"}\n\n![](media/images/w01_s11_census.png){width=100px fig-alt=\"Icon illustrating extracting from a third party source of structured data in the ETL workflow.\"}\n\n![](../shared/images/logo_R.png){width=100px fig-alt=\"R Language Logo\"}\n\n![](../shared/images/logo_Database.png){width=100px fig-alt=\"Generic Database Logo\"}\n\n![](media/images/w01_s11_image.png){width=100px fig-alt=\"Terminal or connector graphic showing extracted data may be unstructured or streaming ETL operations.\"}\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](media/images/w01_s20_grinder.png){width=\"100%\" fig-alt=\"Microsoft Excel Logo\"}\n\n:::\n\n::: {.column width=\"25%\"}\n\n![](../shared/images/logo_Tableau.jpeg){width=100px fig-alt=\"Tableau Logo\"}\n\n![](../shared/images/logo_Database.png){width=100px fig-alt=\"Generic Database Logo\"}\n\n![](../shared/images/logo_Excel.png){width=100px fig-alt=\"Microsoft Excel Logo\"}\n\n![](../shared/images/logo_R.png){width=100px fig-alt=\"R Language Logo\"}\n\n![](../shared/images/logo_SPSS.png){width=100px fig-alt=\"SPSS Logo\"}\n\n:::\n\n:::::\n\n:::\n\n\n\n## Tableau\n\n![](media/images/w01_s26_image.png){fig-alt=\"Tableau branding indicating the visualization tool introduced in this course.\" width=\"100%\"}\n\n## Posit.cloud\n\n![](media/images/w01_s27_image.png){fig-alt=\"Posit Cloud branding indicating a browser‚Äëbased RStudio environment for analysis.\" width=\"100%\"}\n\n## [Coding in R]{.sr-only}\n```{r setup_eco }\nlibrary(eco230r)\nlibrary(dplyr)\n```\n\n::::: columns\n\n::: {.column width=\"10%\"}\n\n![](../shared/images/logo_R.png){width=\"100%\" fig-alt=\"R Language Logo\"}\n\n:::\n\n::: {.column width=\"90%\"}\n<br><br><br>\n```{r idt, echo=TRUE, results=\"hide\"}\nabnb %>%\n  idt(listed_price~instant_bookable)\n```\n<br>\n```{r ano, echo=TRUE, results=\"hide\" }\nabnb %>%\n  ano(listed_price~room_type)\n```\n:::\n\n\n:::::\n\n\n## [Summary and Prime Directive]{.sr-only}\n\n<br><br><br>\n\n### Before running any statistics, what are the three questions you must answer about a dataset?\n\n<br>\n1.  What does one row represent?\n<br>\n2.  What kind of variables do I have?\n<br>\n3.  What question can this data answer?\n","srcMarkdownNoYaml":"\n\n```{r}\n#imports\nsource('../shared/scripts/gt_boland.R')\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(lubridate)\nlibrary(stringr)\nlibrary(glue)\nlibrary(here)\nlibrary(eco230r)\n\n```\n\n\n# Can you trust this conclusion?\n\n## Use Instant Booking Wisely\n\nAirbnb Owners should enable **Instant Booking** in Fall ‚Äî it's the unequivocally best season for superior ratings and returns.\n\n```{r airbnb echo:false}\n\n#install.packages(c(\"readr\",\"dplyr\",\"tidyr\",\"lubridate\",\"stringr\",\"glue\",\"here\"))  # if needed\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(lubridate)\nlibrary(stringr)\nlibrary(glue)\nlibrary(here)\nlibrary(eco230r)\n\n\n# --- Adjust the path to where your file lives ---\ndata_path <- here(\"shared\", \"data\", \"airbnb_chicago.csv\")\ndata_path_sim <- here(\"week01\",\"data\",\"airbnb_chicago_two_properties_bookings_sim.csv\"\n)\n\n# 1) Load data --------------------------------------------------------------\nabnb <- read_csv(data_path, show_col_types = FALSE)\nabnb_sim <- read_csv(data_path_sim, show_col_types = FALSE)\n\n\n# 2) Coerce instant_bookable into logical (t/f/TRUE/FALSE variants) --------\nabnb <- abnb %>%\n  mutate(instant_bookable = tolower(as.character(instant_bookable)) %in% c(\"t\",\"true\"))\n\n# 3) Parse the three date-like columns (WRONG: we will treat these as bookings)\n#    These are listing/host timeline fields, NOT actual stay dates. (That‚Äôs the point!)\nabnb <- abnb %>%\n  mutate(\n    first_review = suppressWarnings(mdy(first_review)),\n    host_since   = suppressWarnings(mdy(host_since)),\n    last_review  = suppressWarnings(mdy(last_review))\n  )\n\n# 4) Stack the three columns into one fake \"booking date\" -------------------\n#    üö© WRONG: we‚Äôre pretending each row *is a booking*, and each of these dates is a booking timestamp.\nlong_wrong <- abnb %>%\n  select(\n    id, listed_price, review_scores_rating, instant_bookable,\n    first_review, host_since, last_review\n  ) %>%\n  pivot_longer(\n    cols = c(first_review, host_since, last_review),\n    names_to   = \"which_date\",\n    values_to  = \"fake_booking_date\"\n  ) %>%\n  filter(!is.na(fake_booking_date))\n\n# 5) Derive a naive season from the calendar month -------------------------\nto_season <- function(m) {\n  if (m %in% c(12, 1, 2))  return(\"Winter\")\n  if (m %in% c(3, 4, 5))   return(\"Spring\")\n  if (m %in% c(6, 7, 8))   return(\"Summer\")\n  return(\"Fall\")\n}\n\n\nlong_wrong <- long_wrong %>%\n  mutate(\n    Season = case_when(\n      month(fake_booking_date) %in% c(12, 1, 2) ~ \"Winter\",\n      month(fake_booking_date) %in% c(3, 4, 5)  ~ \"Spring\",\n      month(fake_booking_date) %in% c(6, 7, 8)  ~ \"Summer\",\n      TRUE                                      ~ \"Fall\"\n    )\n  )\n\n\n# 6) Build the gloriously wrong seasonal summary ---------------------------\n#    - \"bookings\" = count of stacked rows\n#    - \"rating_dollars\" = rating * price  (üö© unit mashup)\nseason_summary <- long_wrong %>%\n  group_by(Season) %>%\n  summarise(\n    bookings      = n(),\n    avg_price     = mean(listed_price, na.rm = TRUE),\n    avg_rating    = mean(review_scores_rating, na.rm = TRUE),\n    instant_share = mean(instant_bookable, na.rm = TRUE)\n  ) %>%\n  ungroup() %>%\n  mutate(\n    rating_dollars = avg_rating * avg_price  # üö© nonsense cross-units\n  ) %>%\n  arrange(desc(rating_dollars))\n\n# 7) Print the confidently wrong conclusion --------------------------------\nbest_season <- season_summary %>% slice(1) %>% pull(Season)\n\n#cat(glue(\"\n#CONFIDENT (but wrong) Conclusion:\n#Enable Instant Book in {best_season} ‚Äî it's the unequivocally best season for superior ratings and returns.\\n\n#\"))\n\n\n\n\n```\n\n```{r ab_flawed}\n\nlibrary(dplyr)\nlibrary(gt)\nlibrary(scales)\n\n\n\nseason_summary %>%\n  mutate(\n    `Avg Price (USD)` = dollar(avg_price, accuracy = 0.01),\n    `Avg Rating`      = number(avg_rating, accuracy = 0.01),\n    `Instant-Book %`  = percent(instant_share, accuracy = 0.01),\n    `Rating √ó Price`  = number(rating_dollars, big.mark = \",\", accuracy = 0.01)\n  ) %>%\n  select(\n    Season,\n    `Bookings` = bookings,\n    `Avg Price (USD)`, `Avg Rating`, `Instant-Book %`, `Rating √ó Price`\n  ) %>%\n  gt() %>%\n  # Minimal typography‚Äîno header, notes, or shading\n  fmt_number(columns = \"Bookings\", decimals = 0, sep_mark = \",\") %>%\n  tab_options(\n    table.width = pct(100),\n    table.font.size = px(24),\n    data_row.padding = px(4),\n    column_labels.font.weight = \"bold\",\n    table.border.top.width = px(0),\n    table.border.bottom.width = px(0),\n    column_labels.border.top.width = px(0),\n    column_labels.border.bottom.width = px(0)\n  )\n\n\n\n```\n\n## [Sample Airbnb Data]{.sr-only}\n\n```{r ab_detail}\n\n\n# Minimalist, slide-friendly gt table for head_20_flags\nlibrary(dplyr)\nlibrary(gt)\nlibrary(stringr)\nlibrary(scales)\nlibrary(lubridate)\n\n\n# 20 rows that should raise eyebrows: these are properties/listings, not bookings.\nhead_20_flags <- abnb %>%\n  select(\n    # IDs & label-like fields that scream \"listing\"\n    id, name, property_type, room_type, neighbourhood, zipcode,\n    # Capacity-level fields (not per-stay)\n    accommodates, bedrooms, beds,\n    # The three date fields we are misusing as bookings (üö©)\n    host_since, first_review, last_review,\n    # Aggregated stats at the listing level (üö© not a single-stay field)\n    number_of_reviews, review_scores_rating,\n    # Price & toggles\n    listed_price, instant_bookable,\n    \n  ) %>%\n  slice_head(n = 20)\n\n\n# OPTIONAL: if you want to (slightly) shorten long listing names before gt\nhead_20_print <- head_20_flags %>%\n  mutate(\n    # Present booleans compactly\n    instant_bookable = ifelse(instant_bookable, \"Yes\", \"No\"),\n    # Nicely formatted numbers\n    listed_price = dollar(listed_price, accuracy = 0.01),\n    number_of_reviews = number(number_of_reviews, big.mark = \",\", accuracy = 1),\n    review_scores_rating = number(review_scores_rating, accuracy = 0.01),\n    # Format dates (use what fits your class better)\n    host_since   = format(as.Date(host_since),   \"%Y-%m-%d\"),\n    first_review = format(as.Date(first_review), \"%Y-%m-%d\"),\n    last_review  = format(as.Date(last_review),  \"%Y-%m-%d\"),\n    # Light truncation to avoid column blowout on slides\n    name           = str_trunc(name,           38),\n    property_type  = str_trunc(property_type,  18),\n    room_type      = str_trunc(room_type,      18),\n    neighbourhood  = str_trunc(neighbourhood,  18),\n    zipcode        = str_trunc(as.character(zipcode), 10)\n  )\n\n# Render with strict widths + tight spacing to fit 20 rows on a slide\ngt_tbl <- head_20_print %>%\n  select(\n    id, name, property_type, room_type, neighbourhood, zipcode,\n    accommodates, bedrooms, beds,\n    host_since, first_review, last_review,\n    number_of_reviews, review_scores_rating,\n    listed_price, instant_bookable\n  ) %>%\n  gt() %>%\n  # Column labels: short & readable (keeps header height small)\n  cols_label(\n    id = \"ID\",\n    name = \"Name\",\n    property_type = \"Property\",\n    room_type = \"Room\",\n    neighbourhood = \"Neighborhood\",\n    zipcode = \"ZIP\",\n    accommodates = \"Sleeps\",\n    bedrooms = \"BR\",\n    beds = \"Beds\",\n    host_since = \"Host Since\",\n    first_review = \"First Review\",\n    last_review = \"Last Review\",\n    number_of_reviews = \"# Reviews\",\n    review_scores_rating = \"Rating\",\n    listed_price = \"Price\",\n    instant_bookable = \"IB?\"\n  ) %>%\n  # Force compact widths: adjust as needed for your slide theme\n  cols_width(\n    id ~ px(68),\n    name ~ px(220),\n    property_type ~ px(120),\n    room_type ~ px(110),\n    neighbourhood ~ px(120),\n    zipcode ~ px(78),\n    accommodates ~ px(70),\n    bedrooms ~ px(60),\n    beds ~ px(60),\n    host_since ~ px(100),\n    first_review ~ px(100),\n    last_review ~ px(100),\n    number_of_reviews ~ px(90),\n    review_scores_rating ~ px(80),\n    listed_price ~ px(90),\n    instant_bookable ~ px(50)\n  ) %>%\n  # Minimal borders, tight padding, small font to fit 20 rows\n  tab_options(\n    table.width = pct(100),\n    table.font.size = px(10),    # try px(11) if still tight\n    data_row.padding = px(2),    # tighter rows\n    column_labels.padding = px(2),\n    table.border.top.width = px(0),\n    table.border.bottom.width = px(0),\n    column_labels.border.top.width = px(0),\n    column_labels.border.bottom.width = px(0)\n  ) %>%\n  # Prevent long strings from expanding columns further\n  opt_vertical_padding(scale = 0.75) %>%\n  opt_horizontal_padding(scale = 0.9)\n\ngt_tbl\n\n```\n\n# What is Statistics?\n\n## {background-image=\"media/images/w01_s03_image.png\" background-position=\"left center\" background-size=\"auto 150%\" background-repeat=\"no-repeat\" fig-alt=\"Photo of several dogs lying on a blanket; playful opener for the topic.\"}\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n\nWhat is **Statistics**?\n\nWhat is **Analytics**?\n\n:::\n\n::::\n\n## {background-image=\"media/images/w01_s03_image.png\" background-position=\"left center\" background-size=\"auto 150%\" background-repeat=\"no-repeat\" fig-alt=\"There are three dogs in this picture. One has black fur, one has brown, one is an idiot.\"}\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n**Analytics** is the **art** of finding out what is in your data.\n\n:::\n\n::::\n\n\n## {background-image=\"media/images/w01_s03_image.png\" background-position=\"left center\" background-size=\"auto 150%\" background-repeat=\"no-repeat\" fig-alt=\"We don't need to see every dog in the world to know that most dogs have fur, they generally have 4 paws etc...\"}\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n\nIf you can (with some effort) find the answer with certainty you are using **Analytics**.\n\n:::\n\n::::\n\n## {background-image=\"media/images/w01_s03_image.png\" background-position=\"left center\" background-size=\"auto 150%\" background-repeat=\"no-repeat\" fig-alt=\"When we need to get specific we need to go beyond analytics. E.g. how much food does the average dog eat?\"}\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n**Analytics** deals with what you know.\n\n**Statistics** deals with what you do not know.\n\n:::\n\n::::\n\n## {background-image=\"media/images/w01_s03_image.png\" background-position=\"left center\" background-size=\"auto 150%\" background-repeat=\"no-repeat\" fig-alt=\"Analytics helps us frame what questions we need clarity on and which questions we need the discipline of statistics to answer.\"}\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n**Analytics** turns curiosity into questions.\n\n**Statistics** turns data into answers.\n\n:::\n\n::::\n\n## {background-image=\"media/images/w01_s03_image.png\" background-position=\"left center\" background-size=\"auto 150%\" background-repeat=\"no-repeat\" fig-alt=\"This picture, a spreadsheet a database, sensor information it is all data in which we can perform analytics and statistics.\"}\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n**Analytics** is the **art** of finding out what is in your data.\n\n**Statistics** is the **science** of making decisions under uncertainty.\n\n:::\n\n::::\n\n::: notes\n-   Open with intuition: students already *do* analytics informally.\n-   Emphasize uncertainty as the key dividing line.\n-   Pause after the third fragment and ask for examples.\n:::\n\n# What does one row represent?\n\n## [Jump to Conclusions 2]{.sr-only}\n\n### Calculate the Total Yearly Revenue for Each Property\n\n```{r ab_grain}\n\n\n# --- Packages ---\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(lubridate)\nlibrary(gt)\nlibrary(stringr)\nlibrary(scales)\n\nset.seed(20260126)  # reproducible sampling for the slide\n\n# Helper: truncation for long text so columns stay narrow on slide\n.trunc <- function(x, width) ifelse(is.na(x), x, str_trunc(x, width = width, side = \"right\", ellipsis = \"‚Ä¶\"))\n\n# -----------------------------------------------------------------------------------\n# 1) Identify properties to show\n#    - Use properties that actually have simulated bookings in `abnb_sim`\n#    - Keep exactly TWO for the booking table, and ensure they also appear in listing table\n# -----------------------------------------------------------------------------------\nsim_ids <- abnb_sim %>%\n  distinct(property_id) %>%\n  pull(property_id) %>%\n  sort()\n\n# Use the first two (or pin explicit IDs if you prefer)\nshow_ids <- head(sim_ids, 2)\n# show_ids <- c(12854553, 743217)  # <- example: pin explicit property IDs\n\n# -----------------------------------------------------------------------------------\n# 2) LISTING-LEVEL TABLE (abnb): 10 total properties including the two with bookings\n# -----------------------------------------------------------------------------------\n# Sample additional properties to reach 10 total (but keep show_ids)\nnum_needed <- max(0, 6 - length(show_ids))\nextra_ids <- abnb %>%\n  filter(!id %in% show_ids) %>%\n  distinct(id) %>%\n  slice_sample(n = num_needed) %>%\n  pull(id)\n\nids_for_abnb_table <- c(show_ids, extra_ids)\n\n# Select columns (include overlap + a few property-only attributes)\nabnb_tbl_data <- abnb %>%\n  filter(id %in% ids_for_abnb_table) %>%\n  select(\n    id, name, room_type, listed_price, accommodates, neighbourhood,\n    bedrooms, bathrooms, beds, cancellation_policy\n  ) %>%\n  arrange(name)\n\n# Render listing-level GT table (compact VT styling, KaTeX-safe headers)\ntbl_abnb_vt <-\n  abnb_tbl_data %>%\n  gt() %>%\n  cols_label(\n    id = \"ID\",\n    name = \"Name\",\n    room_type = \"Room\",\n    listed_price = \"List\",\n    accommodates = \"Sleeps\",\n    neighbourhood = \"N‚Äôhood\",\n    bedrooms = \"BR\",\n    bathrooms = \"BA\",\n    beds = \"Beds\",\n    cancellation_policy = \"Cancel\"\n  ) %>%\n  # Truncate long strings so fixed widths don't wrap\n  text_transform(\n    locations = cells_body(columns = c(name, neighbourhood, room_type, cancellation_policy)),\n    fn = function(x) .trunc(x, width = 28)\n  ) %>%\n  # Currency in cells is fine; KaTeX only cares about headers\n  fmt_currency(columns = listed_price, currency = \"USD\", decimals = 0) %>%\n  # Narrow, predictable column widths for slides\n  cols_width(\n    id ~ px(70),\n    name ~ px(230),\n    room_type ~ px(110),\n    listed_price ~ px(80),\n    accommodates ~ px(75),\n    neighbourhood ~ px(130),\n    bedrooms ~ px(55),\n    bathrooms ~ px(55),\n    beds ~ px(55),\n    cancellation_policy ~ px(110)\n  ) %>%\n  # Minimal borders / tight padding / small font ‚Äî your VT style\n  tab_options(\n    table.width = pct(100),\n    table.font.size = px(9),\n    data_row.padding = px(1),\n    column_labels.padding = px(1),\n    table.border.top.width = px(0),\n    table.border.bottom.width = px(0),\n    column_labels.border.top.width = px(0),\n    column_labels.border.bottom.width = px(0)\n  ) %>%\n  opt_vertical_padding(scale = 0.6) %>%\n  opt_horizontal_padding(scale = 0.8) %>%\n  tab_caption(md(\"**Dataset A** ‚Äî Airbnb Rental Data\"))\n\n# -----------------------------------------------------------------------------------\n# 3) BOOKING-LEVEL TABLE (abnb_sim): 5 random rows per property (for the two selected)\n# -----------------------------------------------------------------------------------\nabnb_sim_tbl_data <- abnb_sim %>%\n  filter(property_id %in% show_ids) %>%\n  transmute(\n    id = property_id,\n    name,\n    room_type,\n    accommodates,\n    neighbourhood,\n    checkin_date = as_date(checkin_date),\n    nights,\n    guest_count,\n    status,\n    price_per_night,\n    total_price = tidyr::replace_na(total_price, 0)\n  ) %>%\n  arrange(name, checkin_date) %>%\n  group_by(id) %>%\n  # Sample exactly 5 random bookings per property (or all if <5)\n  filter(row_number() %in% sample.int(n(), size = min(3, n()), replace = FALSE)) %>%\n  ungroup() %>%\n  arrange(name, checkin_date)\n\n# Render booking-level GT table (compact VT styling, KaTeX-safe headers)\ntbl_abnb_sim_vt <-\n  abnb_sim_tbl_data %>%\n  gt() %>%\n  cols_label(\n    id = \"ID\",\n    name = \"Name\",\n    room_type = \"Room\",\n    accommodates = \"Sleeps\",\n    neighbourhood = \"N‚Äôhood\",\n    checkin_date = \"Check‚Äëin\",\n    nights = \"Nts\",\n    guest_count = \"Guests\",\n    status = \"Status\",\n    price_per_night = \"Price/Nt\",  # no $ in header ‚Üí avoids KaTeX\n    total_price = \"Total\"           # no $ in header ‚Üí avoids KaTeX\n  ) %>%\n  # Truncate long strings to stay within widths\n  text_transform(\n    locations = cells_body(columns = c(name, neighbourhood, room_type, status)),\n    fn = function(x) .trunc(x, width = 24)\n  ) %>%\n  fmt_currency(columns = c(price_per_night, total_price), currency = \"USD\", decimals = 0) %>%\n  cols_width(\n    id ~ px(70),\n    name ~ px(220),\n    room_type ~ px(100),\n    accommodates ~ px(75),\n    neighbourhood ~ px(120),\n    checkin_date ~ px(90),\n    nights ~ px(45),\n    guest_count ~ px(60),\n    status ~ px(90),\n    price_per_night ~ px(90),\n    total_price ~ px(100)\n  ) %>%\n  tab_options(\n    table.width = pct(100),\n    table.font.size = px(9),\n    data_row.padding = px(1),\n    column_labels.padding = px(1),\n    table.border.top.width = px(0),\n    table.border.bottom.width = px(0),\n    column_labels.border.top.width = px(0),\n    column_labels.border.bottom.width = px(0)\n  ) %>%\n  opt_vertical_padding(scale = 0.6) %>%\n  opt_horizontal_padding(scale = 0.8) %>%\n  tab_caption(md(\"**Dataset B** ‚Äî Airbnb Rental Data\"))\n\n\n\n```\n\n```{r ab_property}\ntbl_abnb_vt\n```\n\n```{r ab_bookings}\ntbl_abnb_sim_vt\n```\n\n\n\n## [Rows vs Columns]{.sr-only}\n\n::::: columns\n::: {.column width=\"50%\"}\n### Columns\n\n![](media/images/w01_s19_image.png){fig-alt=\"Icon emphasizing the concept of columns‚Äîvariables‚Äîin a dataset.\" width=\"100%\"}\n:::\n\n::: {.column width=\"50%\"}\n<br><br><br><br><br>\n\n### Rows\n\n![](media/images/w01_s19_image.jpg){fig-alt=\"Icon emphasizing the concept of rows‚Äîobservations‚Äîin a dataset.\" width=\"100%\"}\n:::\n:::::\n\n## Unit of Analysis\n\n::::::: columns\n::: column-page\n**What does each *thingie* (row, observation, grain) of this data represent?**\n:::\n\n:::: {.column width=\"58%\"}\n::: tight-list\n-   Everyone in a *zipcode*\n-   Individual consumers\n-   Individual purchases\n-   GDP of an economy\n-   Population of a planet\n:::\n::::\n\n::: {.column width=\"42%\"}\n![](media/images/w01_s14_image.png){fig-alt=\"Photo of several dogs lying on a blanket; playful opener for the topic.\" height=\"65%\"}\n:::\n:::::::\n\n## Data Grouping: Cross-Sectional {background-image=\"media/images/w01_s15_image.jpeg\" background-size=\"cover\" background-opacity=\"0.95\" fig-alt=\"Freeze‚Äëframe droplet illustrating a cross‚Äësectional snapshot at a single point in time.\"}\n\n## Data Grouping: Time-Series\n\n![](media/images/w01_s16_image.jpeg){fig-alt=\"Growth sequence image suggesting change over time in a time‚Äëseries.\" height=\"85%\"}\n\n## Data Grouping: Panel\n\n![](media/images/w01_s17_image.jpeg){.r-stretch fig-alt=\"Grid‚Äëstyle visual suggesting repeated measures on multiple units across time (panel data).\" fig-align=\"right\"}\n\n# What kind of variables do I have?\n\n## [Tall vs Wide Data]{.sr-only}\n\n### Summarize total minutes of sleep by month and location\n```{r sleep_data echo:FALSE}\nlibrary(readr)\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(stringr)\nlibrary(gt)\nlibrary(here)\n\n# ---- 1) Load with explicit column types ----\n# Adjust the path as needed (from your project root):\ncsv_path <- here(\"week01\", \"data\", \"sleep_tracking_Jan-Jun_2025_with_zip.csv\")\ncsv_path_zips <- here(\"week01\", \"data\", \"simulated_zip_profiles.csv\")\n\n# 1) Load data --------------------------------------------------------------\n\nsleep_zips <- read_csv(csv_path_zips)\n\nsleep <- read_csv(\n  file = csv_path,\n  col_types = cols(\n    Date          = col_character(),   # force character so we control parsing\n    DayOfWeek     = col_character(),\n    Month         = col_character(),\n    PersonName    = col_character(),\n    Gender        = col_character(),\n    Location      = col_character(),\n    SleepEventType= col_character(),\n    StartTime     = col_character(),   # force character\n    EndTime       = col_character(),   # force character\n    TotalMinutes  = col_integer(),\n    REMMinutes    = col_integer(),\n    DeepMinutes   = col_integer(),\n    LightMinutes  = col_integer(),\n    SleepQuality  = col_double(),\n    ZipCode       = col_character()\n  ),\n  show_col_types = FALSE\n)\n\n# ---- 2) Fix Date if it came in as an Excel serial ----\n# If Date looks like a 5-digit integer (e.g., \"45295\"), convert from Excel origin.\nis_excel_serial <- function(x_chr) {\n  all(str_detect(x_chr, \"^\\\\d{4,5}$\"), na.rm = TRUE)\n}\n\nif (is_excel_serial(sleep$Date)) {\n  # Excel's typical origin is 1899-12-30 for most exports\n  sleep$Date <- as.Date(as.numeric(sleep$Date), origin = \"1899-12-30\")\n} else {\n  # Otherwise, parse as ISO or m/d/Y\n  # Try YYYY-MM-DD first, then m/d/Y fallback\n  parsed1 <- suppressWarnings(ymd(sleep$Date, quiet = TRUE))\n  parsed2 <- ifelse(is.na(parsed1),\n                    suppressWarnings(mdy(sleep$Date, quiet = TRUE)),\n                    parsed1)\n  sleep$Date <- as.Date(parsed2)\n}\n\n# ---- 3) Robust parsers for StartTime/EndTime ----\n# These can be \"2025-01-03 22:10\", or \"9/7/2023 10:53 PM\", etc.\nparse_start_end <- function(x_chr) {\n  x_chr <- str_trim(x_chr)\n  # Try multiple common orders:\n  # - \"YYYY-MM-DD HH:MM\"\n  # - \"m/d/Y H:M p\"\n  # - \"Y-m-d H:M:S\" (if seconds exist)\n  # - \"m/d/Y I:M:S p\" etc.\n  parse_date_time(\n    x_chr,\n    orders = c(\n      \"Y-m-d H:M\",\n      \"Y-m-d H:M:S\",\n      \"m/d/Y I:M p\",\n      \"m/d/Y I:M:S p\",\n      \"m/d/y I:M p\",\n      \"m/d/y I:M:S p\"\n    ),\n    tz = \"UTC\"   # keep neutral; display only time-of-day\n  )\n}\n\nsleep$StartTime_dt <- parse_start_end(sleep$StartTime)\nsleep$EndTime_dt   <- parse_start_end(sleep$EndTime)\n\n# If you KNOW StartTime/EndTime are already ISO strings (e.g., \"2025-01-03 22:10\"),\n# you could also use:\n# sleep$StartTime_dt <- ymd_hm(sleep$StartTime, quiet = TRUE)\n# sleep$EndTime_dt   <- ymd_hm(sleep$EndTime, quiet = TRUE)\n\n# ---- 4) Formatters ----\nfmt_time_12h <- function(dt) {\n  # Handle NA gracefully:\n  ifelse(\n    is.na(dt), \n    NA_character_,\n    str_to_upper(format(dt, \"%I:%M %p\")) |>\n      str_replace(\"^0\", \"\") |>\n      str_replace_all(\"AM\", \"A.M.\") |>\n      str_replace_all(\"PM\", \"P.M.\")\n  )\n}\n\nfmt_pct <- function(x) paste0(round(100 * x), \"%\")\n```\n\n```{r sleep_filter echo:FALSE}\n\n\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(readr)\n\nweek_data <- sleep %>%\n  filter(\n    Date >= \"2025-01-05\",\n    Date <= \"2025-01-11\",\n    PersonName %in% c(\"Mike\", \"Cam\"),\n    SleepEventType == \"Main\"\n  ) %>%\n  select(\n    Name        = PersonName,\n    Gender,\n    Location,\n    Date,\n    DayOfWeek,\n    TotalMinutes\n  ) %>%\n  # safety: in case of multiple entries per person/day\n  group_by(Name, Gender, Location, Date, DayOfWeek) %>%\n  summarise(TotalMinutes = sum(TotalMinutes), .groups = \"drop\")\n\n\n```\n\n::::::: columns\n\n:::: {.column width=\"30%\"}\n\n```{r sleep_tall}\n\n\n\ntall_week <- sleep %>%\n  filter(\n    Date >= \"2025-01-05\",\n    Date <= \"2025-01-11\",\n    PersonName %in% c(\"Mike\", \"Cam\"),\n    SleepEventType == \"Main\"\n  ) %>%\n  select(\n    Name        = PersonName,\n    Gender,\n    Location,\n    Date,\n    DayOfWeek,\n    TotalMinutes\n  ) %>%\n  # guard against multiple rows per person/day\n  group_by(Name, Gender, Location, Date, DayOfWeek) %>%\n  summarise(TotalMinutes = sum(TotalMinutes), .groups = \"drop\") %>%\n  # üîë CRITICAL FIX: coerce BEFORE pivot_longer\n  mutate(across(-Name, as.character)) %>%\n  # now pivot safely\n  pivot_longer(\n    cols = -Name,\n    names_to = \"Variable\",\n    values_to = \"Value\"\n  ) %>%\n  arrange(Name, Variable)\n\n\ntall_gt <- tall_week %>%\n  gt(rowname_col = \"Name\") %>%\n  tab_header(\n    title = md(\"**Tall ‚Äî More rows, fewer columns**\")\n  ) %>%\n  cols_label(\n    Variable = \"Variable\",\n    Value    = \"Value\"\n  ) %>%\n  fmt_missing(everything(), missing_text = \"\") %>%\n  tab_options(\n    container.height = px(420),\n    container.overflow.y = TRUE,\n    table.font.size = px(12),\n    data_row.padding = px(4),\n\n    # Remove lines around the title/header and table edges\n    table.border.top.width = px(0),\n    table.border.bottom.width = px(0),\n    heading.border.bottom.width = px(0),\n    column_labels.border.top.width = px(0),\n    column_labels.border.bottom.width = px(0),\n\n    # Optional: remove row separators for a ‚Äúno-chrome‚Äù card look\n    table_body.hlines.width = px(0)\n  )\n\ntall_gt\n\n```\n\n::::\n\n:::: {.column width=\"70%\"}\n\n```{r sleep_wide}\n\nwide_week <- week_data %>%\n  select(Name, Gender, Location, Date, TotalMinutes) %>%\n  pivot_wider(\n    names_from  = Date,\n    values_from = TotalMinutes\n  ) %>%\n  arrange(Name)\n\n\n\nwide_gt <- wide_week %>%\n  gt() %>%\n  tab_header(\n    title = md(\"**Wide ‚Äî More columns, fewer rows**\")\n  ) %>%\n  fmt_missing(everything(), missing_text = \"\") %>%\n  tab_options(\n    container.overflow.x = TRUE,\n    table.width = pct(120),\n    table.font.size = px(12),\n    data_row.padding = px(4),\n\n    # Remove lines around the title/header and table edges\n    table.border.top.width = px(0),\n    table.border.bottom.width = px(0),\n    heading.border.bottom.width = px(0),\n    column_labels.border.top.width = px(0),\n    column_labels.border.bottom.width = px(0),\n\n    # Optional: remove row separators for a ‚Äúno-chrome‚Äù card look\n    table_body.hlines.width = px(0)\n  )\n\nwide_gt\n\n```\n::::\n\n:::::::\n\n\n## Data Types\n\n<br>\n\n### Categories\nTrue/False ‚Üí `logical`  \nCategorical ‚Üí `factor`  \nOrdinal ‚Üí `factor`\n\n<br>\n\n### Numbers\nDiscrete ‚Üí `integer`  \nContinuous ‚Üí `double`\n\n\n\n---\n## Measurement Scales\n\n![](../shared/images/NOIR.svg){width=100% height=700px fig-alt=\"Visual representing Measurement scales Nominal,Ordinal,Interval, Ratio and their common uses. Nominal is more discrete Ratio is more continuous. Nominal is more appropriate for grouping Ratio is more appropriate for Summary statistics like averages and standard deviation. These uses are all on a continuum as the same variable may be used for different purposes.\"}\n\n\n## Observations - Atomic Data\n\n```{r name:sleep_desc echo:False}\n\n\n# ---- 5) Function to build the two tables for a chosen person & date ----\nmake_sleep_tables <- function(data, person = \"Mike\", date_input = \"2025-01-03\") {\n  # Accept either character date or Date class\n  date_val <- if (inherits(date_input, \"Date\")) date_input else as.Date(date_input)\n  \n  row <- data %>%\n    filter(\n      PersonName == person,\n      Date == date_val,\n      SleepEventType == \"Main\"\n    ) %>%\n    arrange(StartTime_dt) %>%\n    slice(1)\n  \n  if (nrow(row) == 0) {\n    stop(\"No 'Main' sleep row found for that person/date.\")\n  }\n  \n  categories_df <- tibble::tibble(\n    Label = c(\"Name\", \"Date\", \"Gender\", \"Location\", \"ZipCode\"),\n    Value = c(\n      row$PersonName,\n      format(row$Date, \"%m/%d/%Y\"),\n      row$Gender,\n      row$Location,\n      row$ZipCode\n    )\n  )\n  \n  numbers_df <- tibble::tibble(\n    Label = c(\n      \"Start Time\",\n      \"End Time\",\n      \"R.E.M.\",\n      \"Deep Sleep\",\n      \"Light Sleep\",\n      \"Total Sleep\",\n      \"Quality\"\n    ),\n    Value = c(\n      fmt_time_12h(row$StartTime_dt),\n      fmt_time_12h(row$EndTime_dt),\n      paste0(row$REMMinutes, \" Minutes\"),\n      paste0(row$DeepMinutes, \" Minutes\"),\n      paste0(row$LightMinutes, \" Minutes\"),\n      as.character(row$TotalMinutes),\n      fmt_pct(row$SleepQuality)\n    )\n  )\n  \n  list(categories = categories_df, numbers = numbers_df)\n}\n\n# ---- 6) Example: reproduce your case (adjust date/person to a known row) ----\ntables <- make_sleep_tables(sleep, person = \"Mike\", date_input = \"2025-01-03\")\ncategories_df <- tables$categories\nnumbers_df    <- tables$numbers\n```\n\n:::::: columns\n::: {.column width=\"30%\"}\n```{r sleep_categories }\n\n\ncategories_df |>\n  gt() |>\n  tab_header(title = md(\"**Categories**\")) |>\n  cols_label(Label = \"\", Value = \"\") |>\n  tab_options(\n    table.width = pct(90),\n    table.border.top.width = px(0),          # line above the title\n    heading.border.bottom.width = px(0),     # line directly under the title\n    column_labels.border.top.width = px(0)   # <-- line you still see (top of labels row)\n  )\n\n\n```\n:::\n\n::: {.column width=\"40%\"}\n![](media/images/w01_s21_image.jpeg){fig-alt=\"Single cube emphasizing an atomic unit of observation in the data.\" width=\"100%\"}\n:::\n\n::: {.column width=\"30%\"}\n```{r sleep_numbers}\nnumbers_df |>\n  gt() |>\n  tab_header(title = md(\"**Numbers**\")) |>\n  cols_label(Label = \"\", Value = \"\") |>\n  tab_options(\n    table.width = pct(90),\n    table.border.top.width = px(0),          # line above the title\n    heading.border.bottom.width = px(0),     # line directly under the title\n    column_labels.border.top.width = px(0)   # <-- line you still see (top of labels row)\n  )\n```\n:::\n::::::\n\n## [Summarized Data]{.sr-only}\n\n:::::::: columns\n:::: {.column width=\"30%\"}\n### Dimensions\n\n::: tight-list\n-   Categories\n-   Filters\n-   Axis Labels\n:::\n::::\n\n::: {.column width=\"40%\"}\n<br> <br> <br> <br> ![](media/images/w01_s22_stack.png){fig-alt=\"An ordered stack of multiple atomic units making it possible to summarize the data with measures and summary statistics.\" width=\"100%\"}\n:::\n\n:::: {.column width=\"30%\"}\n### Measures\n\n::: tight-list\n-   Averages\n-   Standard Deviation\n-   Counts\n-   Sums\n:::\n\n```{r sleep_summary}\njune_glamping <- sleep %>%\n  filter(Month == \"June\", Location == \"Camping\")\n# If you want only main sleeps, uncomment:\n# june_glamping <- june_glamping %>% filter(SleepEventType == \"Main\")\n\nmean_minutes   <- mean(june_glamping$TotalMinutes, na.rm = TRUE)\nmedian_minutes <- median(june_glamping$TotalMinutes, na.rm = TRUE)\navg_quality    <- mean(june_glamping$SleepQuality, na.rm = TRUE)\nn_records      <- nrow(june_glamping)\n\nsummary_vertical <- tibble::tibble(\n  Summary = c(\n    glue(\"Mean = {sprintf('%.2f', mean_minutes)} Minutes\"),\n    glue(\"Median = {round(median_minutes)} Minutes\"),\n    glue(\"Quality = {percent(avg_quality, accuracy = 0.01)}\"),\n    glue(\"N Records = {comma(n_records)}\")\n  )\n)\n\n\nsummary_tbl <-\n  summary_vertical |>\n  gt() |>\n  tab_header(title = md(\"**June Camping**\")) |>\n  cols_label(Summary = \"\") |>\n  # Minimal, readable sizing for slides\n  tab_options(\n    table.width = pct(90),\n    table.font.size = px(18),\n    data_row.padding = px(4),\n\n    # Remove lines around the title/header and table edges\n    table.border.top.width = px(0),\n    table.border.bottom.width = px(0),\n    heading.border.bottom.width = px(0),\n    column_labels.border.top.width = px(0),\n    column_labels.border.bottom.width = px(0),\n\n    # Optional: remove row separators for a ‚Äúno-chrome‚Äù card look\n    table_body.hlines.width = px(0)\n  )\nsummary_tbl\n\n```\n::::\n::::::::\n\n## Tall vs Wide\n\n```{r sleep_dims_cats}\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(gt)\nlibrary(scales)\n\n# --- Load data (uncomment if needed) ---\n# sleep <- read_csv(\"week01/data/sleep_tracking_Jan-Jun_2025_with_zip.csv\",\n#                   show_col_types = FALSE)\n\n# --- Define columns ---\n# Dimensions (categorical / discrete identifiers)\ndims <- c(\n  \"Date\", \"DayOfWeek\", \"Month\",\n  \"PersonName\", \"Gender\",\n  \"Location\", \"SleepEventType\"\n)\n\n# Measures (numeric)\nmeas <- c(\n  \"StartTime\", \"EndTime\",\"TotalMinutes\", \"REMMinutes\", \"DeepMinutes\",\n  \"LightMinutes\", \"SleepQuality\"\n)\n\n# --- Take head(20) and select columns in desired order ---\ntbl20 <- sleep %>%\n  select(all_of(dims), all_of(meas)) %>%\n  slice_head(n = 15)\n\n# --- Format SleepQuality as a percentage for display ---\n# (We‚Äôll use gt::fmt_percent to keep the underlying numeric values numeric.)\n# If SleepQuality is not numeric, coerce it first:\n# tbl20 <- tbl20 %>% mutate(SleepQuality = as.numeric(SleepQuality))\n\n# --- Tableau-like colors (approx) ---\ntableau_blue  <- \"#4E79A7\"  # spanner/header for dimensions (Tableau-like blue)\ntableau_green <- \"#59A14F\"  # spanner/header for measures  (Tableau-like green)\nblue_fill     <- \"#EAF2FB\"  # light blue fill for dimension columns\ngreen_fill    <- \"#EAF6EA\"  # light green fill for measure columns\nheader_text   <- \"white\"\n\n# --- Build gt table with styling ---\ngt_tbl <- tbl20 |>\n  gt() |>\n  # Spanners over the dimension and measure blocks\n  tab_spanner(\n    label = \"Dimensions\",\n    columns = all_of(dims)\n  ) |>\n  tab_spanner(\n    label = \"Measures\",\n    columns = all_of(meas)\n  ) |>\n  # Format SleepQuality as percent with 2 decimals (e.g., 82.35%)\n  fmt_percent(\n    columns = \"SleepQuality\", decimals = 2\n  ) |>\n  # Shade dimension columns (light blue)\n  tab_style(\n    style = cell_fill(color = blue_fill),\n    locations = cells_body(columns = all_of(dims))\n  ) |>\n  # Shade measure columns (light green)\n  tab_style(\n    style = cell_fill(color = green_fill),\n    locations = cells_body(columns = all_of(meas))\n  ) |>\n  # Color the spanner headers to match Tableau-like pills\n  tab_style(\n    style = list(cell_fill(color = tableau_blue), cell_text(color = header_text)),\n    locations = cells_column_spanners(spanners = \"Dimensions\")\n  ) |>\n  tab_style(\n    style = list(cell_fill(color = tableau_green), cell_text(color = header_text)),\n    locations = cells_column_spanners(spanners = \"Measures\")\n  ) |>\n  # Optional: make it a bit tighter and readable\n  tab_options(\n    table.font.size = px(12),\n    data_row.padding = px(6),\n    column_labels.background.color = \"white\",\n    column_labels.font.weight = \"bold\"\n  ) |>\n  cols_label(\n    SleepEventType = \"EventType\",\n    REMMinutes = \"REMMinutes\",\n    DeepMinutes = \"DeepMinutes\",\n    LightMinutes = \"LightMinutes\",\n    TotalMinutes = \"TotalMinutes\",\n    SleepQuality = \"SleepQuality\"\n  )\n\ngt_tbl\n\n\n```\n\n## Principles of Tidy Data\n\n-   *Each variable you measure should be in one column*\n-   *Each observation of that variable should be in a different row*\n-   *There should be one table for each type of observational unit*\n-   *If you have multiple tables you need a key to link them*\n\n```{r tidy_tables}\n\n\n# Packages\nlibrary(dplyr)\nlibrary(gt)\n\n# ---------- TABLE A: sleep (first 10 rows with selected columns) ----------\nsleep_tbl_data <- sleep %>%\n  select(PersonName, Gender, Location, ZipCode, TotalMinutes, SleepQuality) %>%\n  head(10)\n\ntbl_sleep_vt <-\n  sleep_tbl_data %>%\n  gt() %>%\n  cols_label(\n    PersonName   = \"Name\",\n    Gender       = \"Gender\",\n    Location     = \"Location\",\n    ZipCode      = \"ZIP\",\n    TotalMinutes = \"Minutes\",\n    SleepQuality = \"Quality\"\n  ) %>%\n  cols_width(\n    PersonName   ~ px(180),\n    Gender       ~ px(90),\n    Location     ~ px(130),\n    ZipCode      ~ px(90),\n    TotalMinutes ~ px(90),\n    SleepQuality ~ px(90)\n  ) %>%\n  tab_options(\n    table.width = pct(100),\n    table.font.size = px(10),\n    data_row.padding = px(2),\n    column_labels.padding = px(2),\n    table.border.top.width = px(0),\n    table.border.bottom.width = px(0),\n    column_labels.border.top.width = px(0),\n    column_labels.border.bottom.width = px(0)\n  ) %>%\n  opt_vertical_padding(scale = 0.75) %>%\n  opt_horizontal_padding(scale = 0.9) %>%\n  tab_caption(md(\"**Sleep (first 10):** `PersonName, Gender, Location, ZipCode, TotalMinutes, SleepQuality`\"))\n\n# ---------- TABLE B: sleep_zips (first 10 rows) ----------\nsleep_zips_tbl_data <- sleep_zips %>% head(10)\n\ntbl_sleep_zips_vt <-\n  sleep_zips_tbl_data %>%\n  gt() %>%\n  cols_label(\n    zip                     = \"ZIP\",\n    city                    = \"City\",\n    state                   = \"State\",\n    population              = \"Population\",\n    crime_rate_per_100k     = \"Crime per 100k\",\n    avg_sunny_days_per_year = \"Sunny Days\"\n  ) %>%\n  fmt_number(columns = population,              decimals = 0, sep_mark = \",\") %>%\n  fmt_number(columns = crime_rate_per_100k,     decimals = 0, sep_mark = \",\") %>%\n  fmt_number(columns = avg_sunny_days_per_year, decimals = 0) %>%\n  cols_width(\n    zip                     ~ px(90),\n    city                    ~ px(150),\n    state                   ~ px(70),\n    population              ~ px(110),\n    crime_rate_per_100k     ~ px(120),\n    avg_sunny_days_per_year ~ px(100)\n  ) %>%\n  tab_options(\n    table.width = pct(100),\n    table.font.size = px(10),\n    data_row.padding = px(2),\n    column_labels.padding = px(2),\n    table.border.top.width = px(0),\n    table.border.bottom.width = px(0),\n    column_labels.border.top.width = px(0),\n    column_labels.border.bottom.width = px(0)\n  ) %>%\n  opt_vertical_padding(scale = 0.75) %>%\n  opt_horizontal_padding(scale = 0.9) %>%\n  tab_caption(md(\"**Sleep ZIP Profiles (first 10):** `zip, city, state, population, crime_rate_per_100k, avg_sunny_days_per_year`\"))\n\n```\n\n## Tidy Data - Principles 1-3\n\n```{r tidy_base}\n# ---- Display both tables on the slide ----\ntbl_sleep_vt\n```\n\n## Tidy Data - Principle 4\n\n```{r tidy_join}\ntbl_sleep_zips_vt\n```\n\n\n# ETL\n\n## [ETL Process - Extract]{.sr-only}\n\n::: {.text-center}\n\n**Extract** | Transform | Load\n\n:::\n\n::::: columns\n\n::: {.column width=\"33%\"}\nStructured Data\n\n![](media/images/w01_s11_database.png){fig-alt=\"Icon illustrating extracting from a ordered database the ETL workflow.\" width=\"80%\"}\n\n:::\n\n::: {.column width=\"34%\"}\nThird Party\n\n![](media/images/w01_s11_census.png){fig-alt=\"Icon illustrating extracting from a third party source of structured data in the ETL workflow.\" width=\"80%\"}\n:::\n\n::: {.column width=\"33%\"}\nUnstructured Data\n\n![](media/images/w01_s11_image.png){fig-alt=\"Terminal or connector graphic showing extracted data may be unstructured or streaming ETL operations.\" width=\"80%\"}\n:::\n\n:::::\n\n\n## [ETL Process - Transform]{.sr-only}\n\n::: {.text-center}\n\nExtract | **Transform** | Load\n\n::::: columns\n\n::: {.column width=\"25%\"}\n\n![](../shared/images/logo_Excel.png){width=100px fig-alt=\"Microsoft Excel Logo\"}\n\n![](media/images/w01_s11_census.png){width=100px fig-alt=\"Icon illustrating extracting from a third party source of structured data in the ETL workflow.\"}\n\n![](../shared/images/logo_R.png){width=100px fig-alt=\"R Language Logo\"}\n\n![](../shared/images/logo_Database.png){width=100px fig-alt=\"Generic Database Logo\"}\n\n![](media/images/w01_s11_image.png){width=100px fig-alt=\"Terminal or connector graphic showing extracted data may be unstructured or streaming ETL operations.\"}\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](media/images/w01_s20_grinder.png){width=\"100%\" fig-alt=\"Microsoft Excel Logo\"}\n\n:::\n\n::: {.column width=\"25%\"}\n\n\n:::\n\n:::::\n\n:::\n\n## [ETL Process - Transform Example]{.sr-only}\n\n::: {.text-center}\n\nExtract | **Transform** | Load\n\n:::\n\n\n```{r}\n\n# ---- Packages ----\nlibrary(readr)\nlibrary(dplyr)\nlibrary(gt)\nlibrary(stringr)\n\n# ---- 0) Where the file lives ----\n# If you've downloaded via the link, keep the path as-is.\n# Otherwise, set `path` to wherever you've stored the CSV.\npath <- here(\"week01\", \"data\", \"messy_zip_54601.csv\")\n\n\n# ---- 1) Load the messy data (20 rows) ----\nmessy_zip <- read_csv(path, show_col_types = FALSE)\n\n# (Optional) confirm row/col counts in your console:\n# dim(messy_zip)\n# names(messy_zip)\n\n# ---- 2) Small helper: VT styling used across your slides ----\nvt_style_gt <- function(g) {\n  g %>%\n    tab_options(\n      table.width = pct(100),\n      table.font.size = px(10),\n      data_row.padding = px(2),\n      column_labels.padding = px(2),\n      table.border.top.width = px(0),\n      table.border.bottom.width = px(0),\n      column_labels.border.top.width = px(0),\n      column_labels.border.bottom.width = px(0)\n    ) %>%\n    opt_vertical_padding(scale = 0.75) %>%\n    opt_horizontal_padding(scale = 0.9)\n}\n\n# ---- 3) Truncate the very long column so the table fits on a slide ----\n# (Adjust `TRUNC_WIDTH` if you want more/less)\nTRUNC_WIDTH <- 60\nmessy_zip_trunc <- messy_zip %>%\n  mutate(\n    everything_raw = ifelse(\n      is.na(everything_raw),\n      everything_raw,\n      str_trunc(everything_raw, width = TRUNC_WIDTH, side = \"right\", ellipsis = \"‚Ä¶\")\n    )\n  )\n\n# ---- 4) Render ALL 20 rows with VT styling ----\ntbl_messy_zip_vt <-\n  messy_zip_trunc %>%\n  select(zip_value,state_value,county_value,population_value,fips_county,everything_raw) %>%\n  gt() %>%\n  # Keep original column names so the \"messiness\" is apparent\n  # Give a little extra room to long text columns; others will auto-size.\n  cols_width(\n    zip_value        ~ px(110),\n    state_value      ~ px(110),\n    county_value     ~ px(140),\n    population_value ~ px(130),\n    fips_county      ~ px(95),\n    everything_raw   ~ px(380)\n  ) %>%\n  vt_style_gt() %>%\n  tab_caption(md(\"**Messy ZIP 54601**\"))\n\n# ---- 5) Print the table (all 20 rows) ----\ntbl_messy_zip_vt\n\n```\n\n\n## [ETL Process - Load]{.sr-only}\n\n::: {.text-center}\n\nExtract | Transform | **Load**\n\n::::: columns\n\n::: {.column width=\"25%\"}\n\n![](../shared/images/logo_Excel.png){width=100px fig-alt=\"Microsoft Excel Logo\"}\n\n![](media/images/w01_s11_census.png){width=100px fig-alt=\"Icon illustrating extracting from a third party source of structured data in the ETL workflow.\"}\n\n![](../shared/images/logo_R.png){width=100px fig-alt=\"R Language Logo\"}\n\n![](../shared/images/logo_Database.png){width=100px fig-alt=\"Generic Database Logo\"}\n\n![](media/images/w01_s11_image.png){width=100px fig-alt=\"Terminal or connector graphic showing extracted data may be unstructured or streaming ETL operations.\"}\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](media/images/w01_s20_grinder.png){width=\"100%\" fig-alt=\"Microsoft Excel Logo\"}\n\n:::\n\n::: {.column width=\"25%\"}\n\n![](../shared/images/logo_Tableau.jpeg){width=100px fig-alt=\"Tableau Logo\"}\n\n![](../shared/images/logo_Database.png){width=100px fig-alt=\"Generic Database Logo\"}\n\n![](../shared/images/logo_Excel.png){width=100px fig-alt=\"Microsoft Excel Logo\"}\n\n![](../shared/images/logo_R.png){width=100px fig-alt=\"R Language Logo\"}\n\n![](../shared/images/logo_SPSS.png){width=100px fig-alt=\"SPSS Logo\"}\n\n:::\n\n:::::\n\n:::\n\n\n\n## Tableau\n\n![](media/images/w01_s26_image.png){fig-alt=\"Tableau branding indicating the visualization tool introduced in this course.\" width=\"100%\"}\n\n## Posit.cloud\n\n![](media/images/w01_s27_image.png){fig-alt=\"Posit Cloud branding indicating a browser‚Äëbased RStudio environment for analysis.\" width=\"100%\"}\n\n## [Coding in R]{.sr-only}\n```{r setup_eco }\nlibrary(eco230r)\nlibrary(dplyr)\n```\n\n::::: columns\n\n::: {.column width=\"10%\"}\n\n![](../shared/images/logo_R.png){width=\"100%\" fig-alt=\"R Language Logo\"}\n\n:::\n\n::: {.column width=\"90%\"}\n<br><br><br>\n```{r idt, echo=TRUE, results=\"hide\"}\nabnb %>%\n  idt(listed_price~instant_bookable)\n```\n<br>\n```{r ano, echo=TRUE, results=\"hide\" }\nabnb %>%\n  ano(listed_price~room_type)\n```\n:::\n\n\n:::::\n\n\n## [Summary and Prime Directive]{.sr-only}\n\n<br><br><br>\n\n### Before running any statistics, what are the three questions you must answer about a dataset?\n\n<br>\n1.  What does one row represent?\n<br>\n2.  What kind of variables do I have?\n<br>\n3.  What question can this data answer?\n"},"formats":{"revealjs":{"identifier":{"display-name":"RevealJS","target-format":"revealjs","base-format":"revealjs"},"execute":{"fig-width":10,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","html-math-method":{"method":"mathjax","url":"https://cdn.jsdelivr.net/npm/mathjax@2.7.9/MathJax.js?config=TeX-AMS_HTML-full"},"slide-level":2,"to":"revealjs","css":["../shared/styles/accessibility.css"],"toc":false,"self-contained":false,"output-file":"week_01_DEP.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.8.27","auto-stretch":true,"editor":"visual","title":"ECO 230 Section 012","author":"Mike Boland, MBA","theme":["default","../shared/styles/boland-reveal.scss"],"slideNumber":true,"hash":true,"controls":true,"transition":"fade","pdf-export":true,"center":false,"margin":0}}},"projectFormats":["html"]}